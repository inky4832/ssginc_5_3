Reactjs 강좌정리

1. 개요

  - facebook 제공
  - 프런트엔드 프레임워크 ( React.js, Vue.js, Angular )
     ==> JS 기반
  - MVC 패턴에서 V 담당.
  - 가상 DOM 이용해서 빠른 DOM 처리가 가능.
  - 개발방법 2가지 
    가. 함수형 
       - 현재 개발 방법
       - 일반함수 가능
         arrow 함수 가능
       - 클래스 컴포넌트에서만 사용가능한 문법들이 있었음.
         버전업되면서 함수에서도 사용가능하도록 문법지원(hooks 지원)

    나. 클래스
       - 과거에 주로 사용됨.
       

2. React 종류 3가지

   1) CSR ( Client Side Rendering )
     - 웹브라우저에서 화면을 만들고 랜더링하는 방식.
     - 일반적으로 React.js 라고 부름. 

   2) SSR ( Server Side Rendering )
     - JSP처럼 서버에서 화면을 만들고 웹브라우에 응답하여 랜더링되는 방식.
     - 일반적으로 next.js 라고 부름.

   3) Reactive native
     - 모바일용 React 의미.


2. 환경설정

  1) node.js 설치
    - node --version

  2) VSC 설치
  3) VSC 플러그인
    - Reactjs Snippets ( 함수형 기능 제공 )

  4) 크롬 React 확장팩 설치

3. React 프로젝트 생성

  - https://ko.legacy.reactjs.org/docs/create-a-new-react-app.html#createreact-app ( react.js 문법 )
    https://react.dev/learn/start-a-new-react-project  ( next.js 문법 )

   1) 리액트 툴체인
     - facebook 공식 개발툴이고 CSR만 지원됨.
     - 요즘에는 vite 개발툴도 있음.

   2) 방법

    문법:  npx create-react-app 프로젝트명

    가. 설치
     npm install npm -g  <== npx create-react-app 실행시 에러날때.

     npx create-react-app my-app
     cd my-app
     npm start

    나. my-app 폴더 생성

    다. reactjs 버전 변경

       - maven의 pom.xml 역할의  package.json에서 변경

        "react": "^18.3.1",  ------------> "^18.2.0"
       "react-dom": "^18.3.1", ------------> "^18.2.0"

       - npm install  실행하여 변경사항을 적용시킴. ( my-app 디렉터리안에서 )

   3) 실행

       cd my-app
       npm start


         Local:            http://localhost:3000        
         On Your Network:  http://10.10.10.187:3000     

4. my-app 프로젝트 구조

  my-app
     node_modules ( maven의 .m2 저장소 역할 )
     public
       - index.html ( 메인 홈페이지 화면,  화면을 구성하는 특정 js (index.js)파일을 이용해서 화면 랜더링함. )
     src
       - index.js ( App.js 를 import 해서 App.js의 화면을 랜더링 함 )
       - App.js   ( 결론적으로 App.js에서 화면 구축하면 됨 )

     package.json ( maven의 pom.xml 기능 )
     README.md  ( 실행 명령어 제공 )

  
   ==> *.js 마다 *.css 만드는 것이 일반적인 방법임.

5. public  vs src
 
  ==> 이미지 저장 가능하는 폴더임

  1) public
     - 외부에서 접근이 가능
     - build할 때 누락될 수 있음. 따라서 권장안함.

  2) src
     -assets 폴더에 저장.
     -외부에서 접근 불가 ( private)
     - build할 때 누락없이 빌드 가능.


6. 컴포넌트(component)

 1) 개념
   - 일반적으로 하나의 *.js 파일이 화면 하나를 구성.
   -웹 화면에서 보여지는 개별적인 블럭 의미. ( JSP의 top.jsp,menu.jsp,bottom.jsp 비슷 )
   -일반적으로 *.js 파일로 구현됨. 
   -*.js 당 *.css 형태로 구현됨. 
    사용방법은 import './App.css' 형식을 사용함.

   -일반적으로 중첩된 형태(계층구조)로 구현됨.
   
 2) 컴포넌트 종류 2가지

   가. 함수형 컴포넌트
     - 현재 거의 개발할 때 사용됨.

     예> 
         //함수선언식 ( 이름있는 함수)
	 function fun(){}

         //함수표현식 ( 익명 함수 )
	 const fun = function(){};

	 //arrow 표현식
	 const fun = ()->{};

   나. 클래스 컴포넌트
      - skip함

 3) 함수형 컴포넌트
  
  가. 함수명은 반드시 대문자로 지정해야 된다.
    이유는 일반태그가 아닌 React 컴포넌트임을 알려주기 위함.

    예>  function App(){}
        function Person(){}
	function Menu(){}

  
      컴포넌트 사용: <App />
                 <Person />
		 <Menu />

  나. 반드시 return 해야 된다.

   예> function Person(){
   
         return(
	    //JSX 코드 작성 <=== 화면에 랜더링됨.
	 );
      }

  다. 외부에서 사용할려면 반드시 export 해야 된다.

   - export 사용하는 경우

     예>
        export {Menu, Bottom};


	import {Menu, Bottom} from './components/XXX.js'


   - export default 사용하는 경우

    예> 
        export default Menu;

        import Menu from './components/XXX.js'

7. JSX

  1) 개요
   - JSX( Javascript XML ).
   - 웹브라우저에 랜더링되기전에  html 로 변환됨. ( babel 도구 이용 )
     즉 JSX는 웹브라우저에서 직접 사용이 불가능한 비표준문법임.

  2) 특징
  
    - 반드시 root태그가 있어야 됨.
    - JSX에서 JS의 변수값등을 출력할 때는 {변수값} 사용한다.
    - {변수값}는 산술연산자,비교연산자,논리연산자,3항연산자 사용 가능.
    - 논리값(true/false) 와 null은 {변수값} 사용시 출력이 안됨.
      + && 결합해서 조건부 랜더링을 사용할 수 있음.
      예> { true  && <Menu/>}
    - CSS 적용하는 방법
       가. html의 class 속성
         - class 속성명 대신에 className을 사용해야 된다.
	 예> <div className="xxx">

       나. html의 <label for=""> 속성
          - for 속성명 대신에 htmlFor을 사용해야 된다.
          예> <label htmlFor="xxx">

       다. html의 style 속성
         - style 사용할 때는 반드시 중첩 중괄호를 사용해야 된다.
	  예> 
	      var css = {key:value, key:value};
	  
	     <div style={css}
             <div style={{key:value, key:value}}

       * 주의할점
        이전 css 문법의 사용했던 케밥표기법( font-size, background-color)대신에
	카멜표기법( fontSize, backgroundColor )을 사용해야 된다.

         예> <div style={{fontSize:"red", backgroundColor:"yellow"}}


    - && 이용한 조건부 랜더링 ( ******************** )

      예> { 변수 && <Menu />} <=== 변수 true 이면 <Menu /> 컴포넌트가 랜더링됨.
                                     false 이면 <Menu /> 컴포넌트가 랜더링안됨.


    - {...변수} 형식의 spread 연산자 사용 가능

    - 이벤트 구현식 이벤트핸들러는 카멜표기법을 사용해야 된다.

     예> <button onClick={go}>OK</button>

     - JSX 주석
       {/*  JSX 주석 */}

   ==> 결론은 JSX에서 JS 사용할때는 반드시 {} 사용한다.


8. image 사용하기

  - 반드시 src 폴더에 저장하고
    import 해서 사용 권장.

  - 실습
    가. src/assets 폴더 생성
    나. 이미지 저장
    다. import 해서 이미지 사용

     예>
        import daum from './assets/daum.png';

	<img src={daum} width="100" height="100" />


9. props 

 1) 용도
  
   - 화면 레이아웃이 중첩된 형태로 되어있고
     이때 부모 컴포넌트에서 자식 컴포넌트에게 데이터를 전달할 때 사용하는 방법. ( 단방향 )

 2) 특징
   - 단방향 ( 부모에서 자식으로만 전달 가능 )
   - 전달되는 데이터 종류 제한이 없음.
   - 필수가 아닌 옵션

 3) 문법

  가.  속성(property)이용
   예> 
       <Child  key1={값|변수}  key2={값|변수}    />

       function Child(파라미터){  <==== JSON 으로 전달됨. {key1:값, key2:값 }
       }
       function Child({key1, key2}){  <==== 객체분해할당
       }
       function Child({key1, key2}=값){  <==== default 파라미터
       }


  나. body 이용

   예>
       <Child>
          값(문자열, JSX)
       </Child>
       


10. 이벤트 처리

 1) 개요
  - 이벤트 핸들러 (이벤트함수)는 함수 컴포넌트안에서 정의함.

    예>   
        // 함수 컴포넌트
        function App(){
		
          // 이벤트 함수
	  function go(){}

	  
	   return(
	      // JSX
	   );

	}
  
  - JSX에서 이벤트 처리는 카멜표기법(onClick, onChange, ...) 을 사용해야 된다.
  - 기본문법 2가지

   가. 이벤트함수명 이용
    -onClick={이벤트함수명}
    예> onClick={go}

    - 이벤트객체는 자동으로 전달됨.

   나. arrow 함수 이용
    - onClick={arrow함수}
    예> onClick={()=>go(값)}

    - 명시적으로 함수 호출
    - 이벤트객체는 자동으로 전달 안됨. 명시적으로 전달해야 된다.
      예> <button onClick={(e)=>handleEvent1(e)}>OK3</button>

  
 2) 이벤트 객체 사용 가능

   - e.preventDefault();

   - e.stopPropagation();

 

 3) 계층구조 이벤트 처리

  - 부모의 있는 함수를 자식에게 전달 가능하다.
    이 방법을 이용하면 자식이 부모에게 데이터 전달이 가능해진다. ( 계층적 이벤트 + props 이용 )



11. 배열 반복

import logo from './logo.svg';
import './App.css';

  /////////////////////////////////////
  const userList = [{username:"홍길동1",age:20, address:"서울1"},
                    {username:"홍길동2",age:50, address:"서울2"}, 
                    {username:"홍길동3",age:60, address:"서울3"}  
                   ];

  // js 
  var result = userList.map(function(data, idx){
       console.log(data,idx);
       return data;
  });

  var result = userList.map((data, idx)=>{
    return data;
  });

  var result = userList.map((data, idx)=>data);

  console.log(result);

  /////////////////////////////////// 

// 컴포넌트
function Avatar({username, age, address}){

  return(
     <span className="Avatar">
         이름:{username}, 나이:{age}, 주소:{address}
     </span>
  );
}
function App() {

  return (
    <div className="App">
        <h2>1.배열의 첨자이용해서 개별접근</h2>
        회원1: 이름:{userList[0].username}, 나이:{userList[0].age}, 주소:{userList[0].address}<br></br>
        회원2: 이름:{userList[1].username}, 나이:{userList[1].age}, 주소:{userList[1].address}<br></br>
        회원3: 이름:{userList[2].username}, 나이:{userList[2].age}, 주소:{userList[2].address}<br></br>

        <h2>2.Avatar 컴포넌트 이용</h2>
        회원1: <Avatar {...userList[0]} /><br></br>
        회원2: <Avatar {...userList[1]} /><br></br>
        회원3: <Avatar {...userList[2]} /><br></br>


        <h2>3.배열의 첨자 반복</h2>
        {/*
             var result = userList.map(function(data, idx){
                console.log(data,idx);
                return data;
            });

            var result = userList.map((data, idx)=>{
              return data;
            });

            var result = userList.map((data, idx)=>data);

         */}
        {
               userList.map((data, idx)=>{
                  return <div key={idx}>회원{idx+1}: 이름:{data.username}, 나이:{data.age}, 주소:{data.address}</div>
               })
        }
         <h2>4. Avatar 반복1</h2>
         {
               userList.map((data, idx)=>{
                  return <> 
                           <Avatar key={idx}  username={data.username}  age={data.age}  address={data.address}/><br></br>
                         </>
               })
        }
        <h2>4. Avatar 반복2</h2>
         {
               userList.map((data, idx)=>{
                  return <> 
                           <Avatar key={idx}  {...data} /><br></br>
                         </>
               })
        }   

    </div>
  );
}

export default App;
