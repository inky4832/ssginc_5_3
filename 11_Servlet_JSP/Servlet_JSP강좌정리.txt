
Servlet/JSP

1. 자바 개발 플랫폼

  1) Java SE ( Java Standard Edition)
      - 자바 spec.
      - JDK 설치로 SE 환경이 구축됨. 
      - rt.jar
      - 개발할 수 있는 프로그램 형태: 로컬로 실행되는 프로그램.

  2) Java EE ( Java Enterprise Edition)
      - Servlet/JSP spec. ( 인터페이스 개념 ) <=== 나중에 실제 구현체는 Apache의 Tomcat  서버가 제공
      - Tomcat 서버 설치로 EE 환경이 구축됨.
      - servlet-api.jar 와  jsp-api.jar ( 구현체 )
      - 개발할 수 있는 프로그램 형태: 웹브라우저를 이용하는 웹사이트 개발.

  3) Java ME ( Java Micro Edition )
     - 소규모 디바이스에서 동작하는 프로그램 개발
     - 예> 핸드폰, 셋탑박스, ...

2. 환경설정

  1) JDK 11
  2) eclipse
     - http://www.eclipse.org
     - JDK 11를 지원하는 이클립스를 사용해야 됨.
     - eclipse-jee-2022-06-R-win32-x86_64.zip

  3) Tomcat 서버
     - tomcat 9 버전 사용
     - http://jakarta.apache.org
     - servlet-api.jar 와  jsp-api.jar 지원됨.
       패키지명이 javax.servlet 형식으로 시작됨.
     - apache-tomcat-9.0.89.zip
     
       * Tomcat 10 
       패키지명이 jakarta.servlet 형식으로 시작됨.

 
3. eclipse 와 Tomcat 9 연동

  1) eclipse 실행

     - 인코딩 설정 ( UTF-8) 4개 확인

       general > workspace 에서 utf-8로 설정.

       web > css
             html    utf-8로 설정.
	     jsp 

     - JDK 11로 설정하기 (****************)
        preference > Java > Compiler  > 11로 변경.
        preference > Java > installed JRE > 기존 jre 삭제하고 
	           > Add 클릭 > Standard VM 선택 > JRE Home 에 C:\Program Files\Java\jdk-11 설정
		   > Finish > Applys Close
   
   2) eclipse에 Tomcat 9 설정해서 연동
	
      - Severs 탭에 추가된 tomcat 더블클릭하고 Overview 탭 선택 3가지 설정을 변경한다.
       가. server location 에서 Server Path 변경
          - 두번째 라디오버튼으로 변경. ( Use Tomcat installation )

       나. server location 에서 Deploy Path 변경
          - C:\servlet_study\apache-tomcat-9.0.89\webapps 설정.

       다. tomcat의 port 번호 변경
          - 8080 에서 8090로 변경
	   ( 변경하는 이유는 Oracle DB에 tomcat이 내장되어 있고 내부적으로 8080 사용함.
	     충돌방지하기 위해서 8090로 변경)

         * deploy path (배포 경로)
	 - 우리가 만든 웹 어플리케이션을 Tomcat 서버가 클라이언트에게 서비스를 제공한다.
	   이때 우리는 우리가 만든 웹 어플리케이션을 Tomcat 서버가 서비스할 수 있는
	   특별한 디렉토리에 저장해야 된다. 이 작업을 하기 위한 저장 경로를 배포 경로라로 부른다.

          - tomcat의 기본 배포경로는 C:\servlet_study\apache-tomcat-9.0.89\webapps
          - tomcat의 기본 port 는 8080 

   3) Tomcat 9 삭제 방법
 
      preference > Server >  Runtime Enviroments > 설정된 tomcat 삭제
     


4. 프로젝트 생성

  파일 > New > Dynamic Web Project 선택 

  project name: HelloTest

  web Module 화면

   1) Context Root
      - URL에서 사용
       http://localhost:8090/context명/자원(html,css,js,image,jsp,서블릿)
       - context명은 논리적인 이름으로
        실제 tomcat이 webapps (배포경로)에 저장하고 있는
	웹 어플리케이션을 선택하는 역할을 한다.
	내부적으로 다음과 같이 key/value로 구성됨.

	  context명   웹어플리케이션(webapps에 저장된 물리적인 디렉터리)
	  --------------------------
	    key        value
	  
	 예> a           x
	     b          y

        - context명 언제든지 변경 가능하고 대소문자 구별됨. ( 일반적으로 소문자로 사용)
	  단 반드시 / 로 시작해야 됨.


   2) Content Directory
      - 개발자가 만든 소스가 저장되는 디렉토리.
      - 이클립스의 workspace에 저장됨.
	예>
	
	eclipse의 project explorer 화면

	 HelloTest
	   ..
	   java Resources
	     src/main/java ( *.java 가 저장됨, 서블릿)
	     ..
	   src
	     main
	        java       ( *.java 가 저장됨 )
		webapp (*****)
		    META-INF
		      MANIFEST.MF
		    WEB-INF
		       lib
		       web.xml
		    
		    hello.html (정적)
		    test.css
		    test.js
		    test.png
		    world.jsp (동적)

         실행후 tomcat의 webapps 폴더에 배포된 디렉토리 구조는 다음과 같다.
          tomcat
	    webapps
	       HelloTest
                    WEB-INF
		       classes
		           com
			     dto
			       Person.class
			       서블릿
		       lib
		       web.xml
		    
		    hello.html 
		    test.css
		    test.js
		    test.png
		    world.jsp

		    

         * 3가지 컴포넌트
	 가. 정적 ( src/main/webapp 폴더에 저장 )
             - html ( *.html )
	     - JS
	     - CSS
	     - images
	 나. 동적
	     - jsp ( *.jsp ) <== html과 동일한 폴더에 저장. 즉 WEB-INF와 동일한 레벨
	                         html 처럼 비슷한 태그로 구성되었으나 자바코드를 포함할 수 있음.
	     - 서블릿(*.java) <== src/main/java 에 저장. 반드시 패키지로 작성해야 된다.(*****)

       =====> 최종적인 실행 결과는 html로 만들어져야 된다. (**********)


   3) web.xml
      - 배치 지시자 ( deployment descriptor )
      - 개발자가 만든 웹 어플리케이션의 전반적인 설정 정보 담당
       ( 예> filter 등록, 서블릿맵핑, ... )

       web.xml 대신에 어노페이션을 이용할 수도 있음.
    
       - Spring Framework에서 설정 정보를 web.xml로 사용함.

5. Tomcat 서버에 배포하는 디렉터리 구조 (********)

    webapps ( 배포경로의 홈디렉터리)
       폴더(HelloTest) <================== '웹 어플리케이션' 이라고 부른다.
             WEB-INF
	        classes
		    -*.class 저장
	        lib
		  - 나중에 mybatis.jar, mysql-connector.jar 같은 외부라이브러러 저장용
                web.xml 
 
	     *.html
	     *.js
	     *.css
	     *png



6. 클라이언트에서 웹브라우저에 요청하는 URL 문법 (******************)

 
  1) 정적 컴포넌트 요청 ( 디렉터리 없는 경우 )

   http://서버IP번호:port번호/context명/자원

   예> http://localhost:8090/xxx/hello.html        // 논리적인 context명인 /xxx
      http://localhost:8090/HelloTest/hello.html  // 물리적인 web application인 HelloTest 

      http://localhost:8090/xxx/test.css
      http://localhost:8090/xxx/test.js
      http://localhost:8090/xxx/tomcat.svg

   
  2) 정적 컴포넌트 요청 ( 디렉터리 있는 경우 ) <== 일반적인 구조
  
    http://서버IP번호:port번호/context명/디렉터리/자원

     http://localhost:8090/xxx/html/hello.html

     http://localhost:8090/xxx/css/test.css
     http://localhost:8090/xxx/js/test.js
     http://localhost:8090/xxx/images/tomcat.svg

  

   3) 동적 컴포넌트인 JSP 요청 ( 디렉터리 없는 경우 )

      http://서버IP번호:port번호/context명/자원

   예> http://localhost:8090/xxx/world.jsp   


   4) 동적 컴포넌트인 JSP 요청 ( 디렉터리 있는 경우 )

      http://서버IP번호:port번호/context명/디렉터리/자원

   예> http://localhost:8090/xxx/jsp/happy.jsp
   
  * html 동작 정리

          1)요청: http://localhost:8090/xxx/hello.html
    브라우저 ------------------------->   tomcat 서버 (8090)
                                           HelloTest ( 웹어플리케이션) <== 논리적인 이름 컨텍스트명:/xxx
					        WEB-INF
						hello.html

						2) hello.html 찾기
						   없으면 404 에러 발생
						   있으면 찾은 hello.html 다운
						   html은 서버에서 실행되지 않음. 그래서 정적(static)임.
          <-----------------------------------
	    3)응답: hello.html 다운
 4) 다운받고
   html 랜더링

   * JSP 동작 정리 ( 외우기 )
         1)요청: http://localhost:8090/xxx/world.jsp
   브라우저 ------------------------->   tomcat 서버 (8090)
                                           HelloTest ( 웹어플리케이션) <== 논리적인 이름 컨텍스트명:/xxx
					        WEB-INF
						world.jsp

						2) world.jsp 찾기
						   없으면 404 에러 발생
						   있으면 찾은 jsp를 변환한다.
						   (world_jsp.java 생성)
						3) world_jsp.java 컴파일 (컴파일 에러가 발생될 수 있음)
						   world_jsp.class 생성
					   4)  world_jsp.class 실행 (실행되기 때문에 동적 컴포넌트임)
                                             ==> 실행결과는 정적파일인 html로 나옴.
	    <---------------------------------
	       5) 응답: html 다운로드
 6) 다운받고
   html 랜더링

    * JSP 동작 3단계
      1) 변환단계
        world.jsp ---> world_jsp.java
      2) 컴파일 단계
      world_jsp.java --> world_jsp.class
      3) 실행단계
      world_jsp.class --> html



7. 서블릿(Servlet) 작성

  1) 저장 위치

     - src/main/java 
     - 반드시 패키지를 사용해야 됨.
     - servlet-api.jar 에 포함된 패키지를 사용.
       java EE API 문서 확인 가능.
       java.oracle.com 

  2) 문법 (*************)

      import javax.servlet.http.HttpServlet;	
	
    가. extends HttpServlet
    나. 서비스 메서드 재정의
       - 기본이 get 방식인 doGet()를 재정의하자.

    다. 서비스 메서드인 doGet() 안에서 html 작성해서 응답처리

    라. 서블릿 맵핑 (*************)
       ==> 서블릿을 요청하는 url의 별칭을 설정하는 방법이다.
       ==> 2가지 방식으로 설정할 수 있다.
           a. web.xml (*****, Spring 에서 사용하는 방식임 )
	   b. 어노테이션 ( @WebServlet("/별칭") )

     * 서블릿 맵핑 관련 

      OLD 방식: 현재 지원 안됨. 서블릿 맵핑 전 방식임.

             http://localhost:8090/컨텍스트명/servlet/패키지를포함한서블릿명
	
	   ==> HelloServlet 의 OLD 방식?
             
	     http://localhost:8090/xxx/servlet/com.servlet.HelloServlet

	   ==> 이슈 2가지 ?
	       - 매우 길다.
	       - 보안 취약.


      NEW 방식: 서블릿 맵핑
         
       
             OLD 방식:   http://localhost:8090/컨텍스트명/servlet/패키지를포함한서블릿명

	 서블릿 맵핑 방식:  http://localhost:8090/컨텍스트명/서블릿맵핑

	  @WebServlet("/hello") 로 설정했다면 다음과 같이 요청한다.

	  http://localhost:8090/xxx/hello

######################################################
정리

1. 환경설정
   jdk
   eclipse Enterprise 버전
   tomcat 9
     - servlet-api.jar
       jsp-api.jar

2. 3가지 컴포넌트
 
  1) 종류
   정적컴포넌트  : html

   동적컴포넌트  : jsp
               서블릿

  2) 저장위치
   
     src/main/java
                 서블릿(*.java)

     HelloTest
         WEB-INF
         *.html
	 *.jsp

 3) 요청 방법

    html 과 jsp 요청방법:

          http://localhost:8090/context명/html파일(jsp파일)
	  http://localhost:8090/context명/폴더/html파일(jsp파일)


    서블릿 요청방법:
          http://localhost:8090/context명/서블릿맵핑   (**************)


    * 서블릿맵핑2가지
      가. web.xml
      나. @WebServlet("/서블릿매핑")

   ==> 최종적으로 html로 응답된다. (***************)


4. 서블릿 작성방법

   1) extends HttpServlet
   2) 서비스 메서드 재정의 
      - doGet()
   3) 서비스 메서드에서  로직처리 및 html 작성후 응답
   4) 서블릿 맵핑
######################################################################
#####################################################################
2일차

1. 서블릿(Servlet)
   - servlet-api.jar 안의 패키지 이용
     javax.servlet.http 패키지의 HttpServlet 클래스 이용.
   - Java EE API 문서 참고.
     https://javaee.github.io/javaee-spec/javadocs/

   - HttpServlet 의 계층구조


       Servlet(인터페이스): init(),destory(),getServletConfig(),service(,) 
                      , ServletConfig(인터페이스):getInitParameter(String name),getServletContext() 
             |
             |  
       GenericServlet (추상클래스)
             |   :  service(,)
		   init(),destroy()
		   getServletConfig()
		   getServletContext()
		   getInitParameter(String name)
             |
       HttpServlet (추상클래스)
                 : doGet(HttpServletRequest request, HttpServletResponse response)
		   doPost(HttpServletRequest request, HttpServletResponse response)
		   doPut(,)
		   doDelete(,)
		   service(,)
		   init(),destroy()
		   getServletConfig()
		   getServletContext()
		   getInitParameter(String name)
             |
	     |
	 MyServlet (우리가 만들 서블릿 )
	     ==> extends HttpServlet 코드를 작업을 하면
	         웹브라우저의 요청을 처리할 수 있는 클래스가 된다.


     - 서블릿을 작성하는 순서
       1) extends HttpServlet
       2) doGet(HttpServletRequest request, HttpServletResponse response)
          또는 
          doPost(HttpServletRequest request, HttpServletResponse response)
	  메서드를 재정의.
	  기본 서비스 메서드는 doGet().
                 
		    요청(url입력,링크클릭,새로고침,버튼클릭...
		        submit )
	  웹브라우저 ------------------------------------> 서버
                        get요청 ------------------------> 서블릿의 doGet 요청처리
                        post요청 ------------------------> 서블릿의 doPost 요청처리

	       요청의 대부분은 GET 방식으로 요청됨.
	       POST로 요청하는 단 하나의 경우는?
	       <form method="post">

	3) doGet/doPost 메서드에서 비즈니스로 로직 처리하고 html 작성해서 응답처리.
	   - 요청처리(비즈니스 로직 처리)
             ==> 사용자의 요청처리( 폼데이터 처리 예> id/pw 얻기)
	     ==> 유효성 체크 ( DB 연동 )
	     ==> HttpServletRequest request 담당 ( 메서드가 처리 )

           - 응답처리
	     ==> 비즈니스 로직 처리에 대한 결과(id/pw 맞다/틀리다)를
	         사용자에게 알려주는 작업의미.
             ==> HttpServletResponse response 담당 ( 메서드가 처리 )

	4) 서블릿 맵핑
	  
	   - web.xml
	   - @WebServlet("/서블릿맵핑값")



2. 서블릿 맵핑 

    - web.xml
	    <servlet>
		<servlet-name>TestServlet</servlet-name>
		<servlet-class>com.servlet.TestServlet</servlet-class>
	    </servlet>
	    <servlet-mapping>
		<servlet-name>TestServlet</servlet-name>
		<url-pattern>/xxx3</url-pattern>
	    </servlet-mapping>

    - @WebServlet("/서블릿맵핑값") <== eclipse가 자동으로 지원 맵핑 방법


3. 서블릿 특징
 
   - main 메서드가 없다.( 시작점이 따로 없다는 의미)
    즉 사용자가 맨 처음 요청하는 서블릿이 시작점 역할을 담당한다.
   - 서블릿을 명시적으로 new(객체생성) 안함.
     Tomcat이 서블릿/JSP의 LifeCycle(생성~소멸)을 관리한다.
   - 서블릿은 단 한번만 생성됨. 
     thread-unsafe: 인스턴스변수 
     thread-safe: doGet의 로컬변수 (*****)

4. 서블릿의 LifeCycle 

  - 콜백 메서드가 제공됨.

  가. 서블릿 생성될 때 호출되는 콜백 메서드
    - init()
    - 용도: 서블릿이 생성될 때 초기화 작업 처리.
    - 중요: 
       서블릿은 단 한 번만 생성됨. 따라서 init() 메서드도 단 한번만 호출됨.
       따라서 서블릿에서 인스턴스 변수를 작성하면 여러 사용자들이 공유하게 됨.(보안에 매우 취약해짐)
            인스턴스 변수 사용은 권장안함.
       thread-unsafe 하다고 함.
       thread-safe하게 작성하는 방법은 doGet의 로컬 변수로 작성해야 된다.


  나.  서블릿 요청될 때 호출되는 콜백 메서드
    - doGet/doPost
    - 용도:  요청처리 와 응답처리

  다.  서블릿 소멸될 때 호출되는 콜백 메서드
     - destory()
     - 용도: 서블릿이 소멸될 때 clean up 작업 처리.


5.  서블릿의 응답처리
 
  - 응답처리 개념
    ==> 웹브라우저에서 볼 수 있도록 html 작성하는 처리의미.
  - 담당
    => doGet의 두 번째 파라미터인 HttpServletResponse 가 처리함.

  - HttpServletResponse 인터페이스의 메서드 확인

     response.addCookie(Cookie cookie): 쿠키 저장할 때 사용. 300개가 가능
     response.addHeader(String name, String value) : 응답 헤더에 헤더값을 추가할 때 사용.
     response.getHeader(String name) : 응답 헤더값을 얻을 때 사용.
     response.getStatus():           응답에 대한 status 값
    
     response.sendRedirect(String location): 서블릿에서 JSP로 위임할 때 사용.
     response.setContentType(String type)   :  웹 브라우저에게 처리할 데이터의 종류를 알려주는 기능.
                                               MIME 타입이라고 부름
					       Servers > web.xml 에서 종류 확인 가능.
					       예> text/plain : 일반 텍스트로 전달
					          text/html:   html로 전달
						  application/json: JSON으로 전달

     PrintWriter out = response.getWriter();
     out.print(값);  // 이 값이 웹 브라우저에 출력됨.

     System.out.println(값);  // tomcat의 console에 출력

    


     * 헤더 정보(header)

                     요청
		     (요청헤더가 전달됨)
		      method:get
		      Accept:text/html;~~~
		      Accept-Language: ko-kr,~
		      User_Agent: Mozilla~
     웹브라우저 ----------------------------> 서버
             <----------------------------
	            응답
		     (응답헤더가 전달됨)
		     Content-Type:text/html; charset=utf-8

 - 웹브라우저에 html 출력하는 방법

   가. MIME 설정
     response.setContentType("text/html");  // 한글처리: "text/html;charset=utf-8"

   나. html작성 출력
  
     PrintWriter out = response.getWriter();
     out.print("html코드");

  ==> 서블리에서 하는 응답처리는 쉽지않다.
     따라서 실제로는 서블릿에서 응답처리 하지 않음.
     대신 JSP에 위임해서 응답처리를 작업한다.

    예>
       1) 현재상황
                                      서버
       웹브라우저 ------------------>  서블릿
               <------------------

      2) 변경된 구조

                                     서버
       웹브라우저 ------------------>  서블릿
                                      |
                                      | 위임( 2가지 방법)
				          -response.sendRedirect(String location):
					  -request.getRequestDispatcher(String path):
               <------------------   jsp


6.  서블릿의 요청처리

  - 요청처리 개념
    ==> 웹브라우저에서 요청했을 때 서블릿에서 처리하는 작업의미.
       예> 사용자입력 데이터 얻기.
           한글처리
	   ..
  - 담당
    => doGet의 첫 번째 파라미터인 HttpServletRequest 가 처리함.

  - HttpServletRequest 인터페이스의 메서드 확인

     request.getContextPath() : 요청 URL에서 context명 얻을 때 사용.
     request.getCookies():      쿠키를 배열로 반환. Cookie[]
     request.getHeader(String name) : 요청헤더값 얻을 때 사용.
     request.getQueryString():    요청 URL에서 ?name=value&name=value
     request.getSession():      세션 얻을 때 사용. 매우중요(로그인시 사용됨)

     request.setAttribute(key,value);  // key/value쌍으로 데이터 저장할 때 사용
     request.getAttribute(key);        // key 이용해서 value 얻을 때 사용.
     
     request.setCharacterEncoding(String env):  "utf-8" 지정해서 한글처리 가능

     // 다음 4개이 메서드로 사용자 입력 데이터를 얻을 수 있다.
     request.getParameter(String name) :
      ==> 무조건 String 반환됨.
      ==> 일치하지 않는 name 지정하면 null 반환됨.
      ==> GET 방식으로 요청했을때 한글처리가 되서 한글이 잘 나옴.
      ==> POST 방식으로 요청했을때 한글처리가 안됨. 한글이 깨짐
           request.setCharacterEncoding("utf-8")

     request.getParameterNames():
     request.getParameterValues(String name):
     request.getParameterMap():

     request.getRequestDispatcher(String path):  서블릿에서 JSP로 위임할 때 사용.
     

  - 요청처리 실습하기 위한 구조
                                              서버
                1) jsp 요청
   웹 브라우저  ---------------------------->   memberForm.jsp ( 회원가입화면 )
             <----------------------------
	        2) 응답
  3) html랜더링
  id: aaa
  pw: 1234           4) 요청
  로그인버튼클릭 ----------------------------------> MemberServlet


7. 경로 
 
  1) 절대경로
    - / 로 시작.
    - 서블릿에서  / 는 다음 URL에서  8090 뒤의 / 를 의미한다.
     즉 / 를 기준으로 경로를 선택하는 방법이다.
 
     예> http://localhost:8090/app5/memberForm.html

        action="/login" <===  8090/login 의미.
	href="/~"
	src="/~"

  2) 상대경로
    - / 로 시작안하고 . 또는 .. 사용
    - 현재 URL에 보여지는 페이지의 경로를 기준으로 경로를 선택하는 방법이다.

8. 405 에러 

 - 발생되는 경우는 

    클라이언트의 method="get|post" 과  서블릿의 doGet|doPost 가 일치하지 않는 경우에 발생됨.

#############################################3
2일차 리뷰

1. 클라이언트에서 요청하는 4가지 작업


  클라이언트(사용자)  ------------------------->  MySQl 서버
                    select (Read)
		    insert (Create)
		    update (Update)
		    delete (Delete)


   클라이언트(사용자)      ------------------------------------->  Tomcat 서버
   method:GET|POST                                              서블릿
                                get(Read) ------------------>doGet
                                post(create,delete,update)--->doPost

   REST API:GET|POST|PUT|DELETE      get(Read) ------------------>doGet
                                     post(Create)---------------->doPost
				     PUT(update) ----------------->doPut
				     DELETE(delete) --------------->doDelete


2. HttpServletRequest 와 HttpServletResponse

            요청(GET:기본)                    서블릿
           - 사용자입력(폼데이터,파라미터)얻기
	  String userid = request.getParameter("name값");
웹브라우저 ------------------------------>  doGet(HttpServletRequest request,
                                                HttpServletResponse response){}
	<------------------------------
	    응답
	    response.setContentType("text/html;charset=utf-8");
	    PrintWriter out = response.getWriter();
	    out.print("html코드");
	    ==> 서블릿이 직접 html코드를 작성하는 작업은 매우 고된 작업이다.
                나중에는 JSP에게 위임해서 처리한다.

    *request 와 response 는 어떤 변수?
      - 로컬변수
      - 요청~응답 사이의 lifecycle를 가짐.
       따라서 첫번째 요청에서의 HttpServletRequest 와 
            두번째 요청에서의 HttpServletRequest 는 서로 다른다. (*****************************)

####################################
3일차

1. 요청처리
  
  - request.getParameter("name"):String

  - request.getParameterValues(String name): String []
   예> checkbox
   동작방식은 check된 값만 서버에 전달이 된다.


  - 이름을 먼저 조회하고 나중에 값을 얻을 수 있다.

    request.getParameterNames(): Enumeration<String>>

   
   * java.util.Iterator  vs  java.util.Enumeration

     가. Iterator 사용방법

        while(ite.haxNext()){

	       ite.next();
	}

     나. Enumeration 사용방법

        while(enu.hasMoreElements()){

	       enu.nextElement();
	}


2. scope (lifecycle)
 
 - 자바의 변수에서 사용했던 scope와 비슷
   예> 로컬변수 : 메서드 호출 ~ 메서드 종료

      인스턴스 변수: 객체생성~객체소멸
      클래스 변수(static): 프로그램 실행 ~ 프로그램 종료

 - 서블릿에서 사용하는 3가지 scope 
   0) page scope (skip)
     
   1) request scope
      - HttpServletRequest 가 실체임
      - 데이터 저장기능도 포함
         setAttribute(String name,Object o) 로 저장.
         getAttribute(String name) 로 조회.
         removeAttribute(String name)로 삭제.
	 getAttributeNames() 로 name부터 조회

      - 저장된 데이터의 scope(lifecycle)?
                     1번 요청                     SetServlet
         웹브라우저 -----------------------------> doGet(HttpServletRequest request, ... ){
						     request.setAttribute("xxx","홍길동");
	                                         }
                 <-----------------------------
		    응답

		    2번 요청                       GetServlet
                 -------------------------------->doGet(HttpServletRequest request, ... ){
						     request.getAttribute("xxx"); // null반환
	                                         }

   2) session scope
      - HttpSession 가 실체임
      - 데이터 저장기능도 포함
         
	 setAttribute(String name,Object o) 로 저장.
         getAttribute(String name) 로 조회.
         removeAttribute(String name)로 삭제.
	 getAttributeNames() 로 name부터 조회

     - HttpSession 얻는 방법 ( 로그인 기능처리 )
        
	 HttpSession session = request.getSession(); 
	 HttpSession session = request.getSession(true); 
	  # Returns the current session associated with this request, or 
	  if the request does not have a session, creates one.
	 세션(session)이 있으면 현재 세션(session)을 반환하고 없으면 새로 생성해서 반환.
	 ------------------------------------------------
         HttpSession session = request.getSession(false); 
          # If create is false and the request has no valid HttpSession, this method returns null.
           세션(session)이 있으면 현재 세션(session)을 반환하고 없으면 null 반환.
 
      - 저장된 데이터의 scope(lifecycle)?
        ==> 동일한 웹 브라우저와 scope가 같다.
	    즉 요청한 웹브라우저를 close하지 않으면 session에 저장된 정보는 계속 유지된다.
	    (요청한 웹브라우저를 close할 때까지 유지함)


                      1번 요청                     SetServlet
         웹 브라우저 -----------------------------> doGet(HttpServletRequest request, ... ){
	 (크롬)					     session.setAttribute("xxx","이순신");
	                                         }
                 <-----------------------------
                      응답

                    2번 요청                       GetServlet
                 -------------------------------->doGet(HttpServletRequest request, ... ){
						     session.getAttribute("xxx"); // 이순신 반환
	                                         }

                            2번 요청               GetServlet
          웹 브라우저  -------------------------------->doGet(HttpServletRequest request, ... ){
	 (엣지)					     session.getAttribute("xxx"); //null 반환
	                                         }


      - tomcat이 요청하는 웹브라우저의 정보를 알고 있다. (JSESSIONID 값을 이용)
                         id전송
			 JSESSIONID=5B5C1DC28B5133BE0E7B19931C4EC058
          웹브라우저(크롬) ---------------------> Tomcat ( 요청한 크롬웹브라우저 id 저장함)
	                 id전송
			 JSESSIONID=12F7E322D0401F556A4A27F4B0610037
          웹브라우저(엣지) ---------------------> Tomcat ( 요청한 엣지웹브라우저 id 저장함)
 
   
       - time-out 설정
        이론적으로는 요청한 웹브라우저가 close되지 않으면 서버에 저장된 세션(HttpSession, 빨강박스)은
	제거되지 않는다.
	하지만 보안 이슈 때문에 요청한 웹브라우저가 close되지 않아도 일정 시간이 지나면 
	자동으로 세션(HttpSession, 빨강박스)을 삭제시킨다.
	 tomcat의 기본 time-out는 30분이다. ( servers > web.xml 에 설정되어 있음 )

	* 개발자가 명시적으로 time-out 설정 가능

	  1) web.xml 에서 설정 ( 단위는 minutes)
	       <session-config>
		<session-timeout>60</session-timeout>
	       </session-config>

	  2) 자바 코드로 설정 ( 단위 seconds )

	      session.setMaxInactiveInterval(60*60);  // 3600초, 1시간


      - 명시적으로 세션 데이터 삭제

        가. 세션 엔트리 삭제
	 
	  sesssion.removeAttriute("key");
	  - 장바구니에 저장된 요소 삭제하는 경우

	나. 세션 전체 삭제(HttpSession, 빨강박스)

	  session.invalidate()
	  - 로그아웃할 때 사용


   3) application scope

      - ServletContext 가 실체임
      - 데이터 저장기능도 포함
         setAttribute(String name,Object o) 로 저장.
         getAttribute(String name) 로 조회.
         removeAttribute(String name)로 삭제.
	 getAttributeNames() 로 name부터 조회


       - 저장된 데이터의 scope(lifecycle)?
        ==> Tomcat 과  scope가 같다. 
	   (정확히는 Web Module에 올라간 실행중인 Context와 scope 가 동일)

      - ServletContext 얻는 방법 

       ==> HttpServlet(사실은 ServletConfig에서 제공)에서 제공되기 때문에
           doGet메서드내에서 getServletContext() 사용하면 된다.

	  예> doGet(,){

            ServletContext application = getServletContext();
             application.setAttribute("application","유관순");
	  }


3. JSP ( Java Server Page)

  1) 특징
    - 동적 컴포넌트 ( 서버에서 실행되어 동적으로 결과를 만듬 )
    - *.jsp 확장자를 가짐.
    - 서블릿은 요청하면 doGet/doPost 같은 서비스가 실행됨.
      JSP는 요청하면 3단계를 거쳐서 실행됨.

      가. 변환단계
         .jsp --> .java ( 서블릿과 매우 유사한 코드임)
	 
      나. 컴파일 단계
         *.java ----> *.class

      다. 실행 단계
         *.class ---> 결과반환( 결과는 html로 반환됨 )

     - JSP내의 대부분의 코드는 html이다.
       약간씩 자바코드가 포함된다.
       따라서 화면처리는 JSP가 더 잘함.

       Servlet의 대부분의 코드는 java코드이다.
       약간씩 html가 포함된다.
       따라서 비즈니스 로직처리는 Servlet이 더 잘함.


 2) JSP 구성요소

    가. html 

    # 다음 태그는 java와 관련있는 태그이다.
    나. JSP 태그
        *종류
	 - directive 태그
	        - page directive 태그 :  JSP에게 정보를 알려줄 때 사용된다.
		                        정보종류? contenType, 자바의 import,...
		      <%@ page  속성명="속성값"  속성명="속성값" ...         %>

		- include directive 태그: <%@ include  file="속성값" %>
		- taglib directive 태그 : <%@ taglib   prefix="속성값" uri="속성값"  %>

	 - declaration 태그  : 인스턴스변수/인스턴스 메서드 ( 거의 사용 안함 )
	     <%!  자바코드   %>
	 - scriptlet 태그    : 서비스메서드내에서 코드 ( 매우 많이 사용됨 )
	      <%   자바코드   %>  
	 - expression 태그   : <%=  변수(값)  %>

    다. EL 태그
    라. JSTL 태그

#############################################
3일차 리뷰

1. 서블릿(servlet)
 
  1) 서블릿의 계층구조


      Servlet(인터페이스, init(),destory()..) , ServleConfig(인터페이스, getServletContext())
          |
      GenericServlet(추상클래스, ....)
          |
      HttpServlet (추상클래스, doGet|doPost|doPut|doDelete,....)
          |
      MyServlet

  2) 서블릿 작성방법

    가. extends HttpServlet
    나. doGet(HttpServletRequest request, HttpServletResponse response){}
       /doPost 재정의
    다. 요청처리/응답처리 구현

       -요청처리
        : HttpServletRequest request 이용

        : 사용자 입력 데이터 얻기
	  ==> String value = request.getParameter(name);  // request.getAttribute(name) 구별필요.
              String []values = request.getParamterValues(name);
	
	      //먼저 name값 조회
	      Enumeration<String> enu = request.getParameterNames();
	      while(enu.hasMoreElements()){
                   String name = enu.nextElement();
		   String value = request.getParameter(name);
	      }
	: POST 한글처리
	  ==> request.setCharacterEncoding("utf-8");

	: 세션(빨강 박스) 얻기
	  
	  # 세션이 있으면 존재하는 세션을 반환하고 없으면 새로 생성해서 반환.
	   HttpSession session = request.getSession();
	   HttpSession session = request.getSession(true);
          --------------------------------------------------
          # 세션이 있으면 존재하는 세션을 반환하고 없으면 null 반환
	   HttpSession session = request.getSession(false);


       -응답처리
        : html 작성 결과물을 
	  클라이언트로 전송.
	: HttpServletResponse response

	: html 작성방법

	  가. 웹브라우저에게 제공할 content의 정보를 알려줘야 됨.
	     ( MIME 타입 설정이라고 부름)

		response.setContentType("text/html;charset=utf-8");


          나. 실제 html 전송 ( java i/o 사용 )
	   
	    PrintWriter out = response.getWriter();
	    out.print("html작성");

     라. 서블릿 매핑
        - web.xml
	- @WebServlet("/서블릿 매핑")

2. JSP ( Java Server Page )

 - 내부적으로 서블릿(servlet)으로 실행됨.
 - 3단계

 가. 변환단계
   a.jsp --> a_jsp.java ( 서블릿 )
   ==>  a_jsp.java 는 서블릿에서 구현했던 작업들이 모두 구현이 되어 있음.


      서블릿(직접)                  JSP(변환된 서블릿)
      extends HttpServlet         extends JspBaseServlet
      doGet/doPost                _jspService(HttpServletRequest request, 
                                               HttpServletResponse response)

      doGet(HttpServletRequest x,
       HttpServletResponse y){}

       out.print("<html>")              out.write("<html>")




 나. 컴파일단계
 다. 실행단계

 - 서블릿으로 만들수 있으면 JSP로도 구현이 가능함.

 ############################################################

4일차

1. JSP 구성요소 ( 태그 형태로 구성됨 )

    가. html 

    # 다음 태그는 java와 관련있는 태그이다.
    나. JSP 태그
        *종류
	 - directive 태그
	        - page directive 태그 :  JSP에게 정보를 알려줄 때 사용된다.
		                        정보종류? contenType, 자바의 import,...
		                  <%@ page  속성명="속성값"  속성명="속성값" ...         %>
		                     : 여러번 사용이 가능

			<%@ page contentType="text/html;charset=utf-8" %>
			 ==> 서블릿의 response.setContentType("text/html;charset=utf-8") 기능.
	                
			<%@ page import="java.util.ArrayList" %> 
                        <%@ page import="java.util.Date" %>
			<%@ page import="java.util.Date,java.util.ArrayList" %>
			 ==> 서블릿의 import java.util.ArrayList;
			            import java.util.Date; 


	
		- include directive 태그: 화면을 재사용할 때 사용.
		
		       <%@ include  file="속성값" %>


		- taglib directive 태그 : <%@ taglib   prefix="속성값" uri="속성값"  %>

	 - declaration 태그  : - 인스턴스변수/인스턴스 메서드 ( 거의 사용 안함 )
	               <%!  자바코드(인스턴스변수|메서드)   %>
			      - 여러번 사용 가능	
		       예>
		           <%!
			       int num=10;
			       public void a(){
			          System.out.println(num);
			       }
			   %>
			  ==> 서블릿에서는
			       
			        public class MyServlet extends HttpServlet{

                                     int num=10;
			             public void a(){
				        System.out.println(num);
				     } 
                                     public void doGet(){}
				}


	 - scriptlet 태그    : -서비스 메서드(doGet/doPost)내에서 코드 ( 매우 많이 사용됨 )
	                      <%   자바코드   %>  
			      - 여러번 사용 가능
			   예>
			     서블릿의 doGet() 구현 코드예-1
			     pulic void doGet(HttpServletRequest x,
			                      HttpServletResponse y){
				  
				  int n = 10;
				  int [] arr = {10,20};
				  for(int k: arr){
                                     System.out.println(k);
				  }

			     }

			     JSP에서는 다음과 같이 표현한다.- 1 
			     <%
                                  int n = 10;
				  int [] arr = {10,20};

			     %>
			     <%
                                 for(int k: arr){
                                     System.out.println(k);
				  }
 
			     %>

	
	                    서블릿의 doGet() 구현 코드예-2
			     pulic void doGet(HttpServletRequest x,
			                      HttpServletResponse y){
				  
				 String userid =
				   x.getParamter("userid");
				 
				 HttpSession session= x.getSession();

				 x.setCharacterEncoding("utf-8");

				 y.setContentType("text/html;charset=utf-8");
				 PrintWriter out = y.getWriter();  
				 out.print("<html>");
			     }
	
			    JSP 표현-2
			    =>변환하면 항상 _jspService(HttpServletRequest request,
			                             HttpServletResponse response){
						     String userid = request.getParamter("userid");
						     }
			    <%
                                   String userid = request.getParamter("userid");
				   HttpSession session= request.getSession();

				    request.setCharacterEncoding("utf-8");

			    %>
			   
				
			   서블릿의 doGet() 구현 코드예-3
			     pulic void doGet(HttpServletRequest request,
			                      HttpServletResponse response){
				  
				 String userid =
				   request.getParamter("userid");

				 request.setAttribute("xxx","이순신");
				 
				 HttpSession session= request.getSession();
				 session.setAttribute("xxx","홍길동");

				 request.setCharacterEncoding("utf-8");

				 ServletContext application = getServletContext();
				 application.setAttribute("xxx","유관순");

				 response.setContentType("text/html;charset=utf-8");
				 PrintWriter out = response.getWriter();  
				 out.print("<html>");
			     }

			  JSP 표현-3
			    =>변환하면 항상 _jspService(HttpServletRequest request,
			                             HttpServletResponse response)가 자동생성됨.
                            => 항상 자동으로 선언되는 변수가 있음.
                                   HttpSession session;
                                   ServletContext application; 
				   ServletConfig config;
				   JspWriter out;  // PrintWrtier 동일 기능
                            <%
			        // 내장변수(내장객체) 라고 부른다.
                                 request.메서드
				 response.메서드
                                 session.메서드
				 application.메서드
				 config.메서드
				 out.print("값");
			    %>

	 - expression 태그   : <%=  변수(값)  %>
	                      <%  out.print("값"); %> 동일한 기능.


        * 서블릿 코드

	  public void doGet(HttpServletRequest request,
	                    HttpServletResponse response){

             List<String> list = Arrays.asList("홍길동","이순신");

	     out.print




    다. EL 태그
    라. JSTL 태그
      - taglib directive 태그 : <%@ taglib   prefix="속성값" uri="속성값"  %> 사용
   

2. 화면 재사용

 1) include 디렉티브 이용한 방법. ( 정적인 방법 )


    jsp05_화면재사용1_include디렉티브.jsp               copyright.jsp

   <body>
	내용
	<hr>
	<!-- copyright 위치 -->
	<%@ include file="copyright.jsp"%>
  </body>

 
 2) jsp include 액션 태그 이용한 방법. ( 동적인 방법 )

   <body>
	내용
	<hr>
	<!-- copyright 위치 -->
	<jsp:incldue  page="copyright.jsp"  flush="true" />
  </body>



3. 서블릿에서 JSP로 위임 (*********************)

   1) 개요
    - 서블릿: - 대부분이 자바코드이고 약간이 html임.
              약간의 html 작업조차도 매우 번거로운 작업이다.
            - 비즈니스 로직처리를 잘함. 
	      
    - JSP:  - 대부분이 html이고 약간 java코드 임.
            약간의 java코드 작업은 <% %> JSP태그를 사용해야 됨.
            - 화면처리를 잘함.


   2) 구조


    가. 현재 방식
                      요청(잘함)
        웹브라우저 ---------------------> 서블릿
	        <---------------------
		     응답 ( 매우 힘들게 처리함 )


                       요청 (자바처리가 번거로움 )
        웹브라우저 ---------------------> jsp
	        <---------------------
		     응답 (잘함)


    나. 적용할 방식 ( ************** )

                   요청 (잘함 )
      웹브라우저 -----------------------> 서블릿
                                         | 
					 | 위임처리 ( 요청 )  
                                         |
              <----------------------  jsp
	          응답 ( 잘함)


    3) 위임처리 방법 2가지

     가. 리다이렉트(redirect) 
	- HttpServletResponse 이용
        - 문법:
	 public void doGet(HttpServletRequest request, HttpServletResponse response){
	  
	   
	   response.sendRedirect("타겟");
         }


                    1) 요청(/xxx)
     웹브라우저 ------------------>    MainServlet("/xxx") 2) doGet실행
                                                 HttpServletRequest request(100번지) 생성
						 request(100번지).setAttribute("xxx","홍길동")
						 3)
                                                 response.sendRedirect(" a.jsp");
             <-------------------
	            4)응답(서블릿이 응답)

                   5) 재요청(a.jsp)
              ------------------>  a.jsp   HttpServletRequest request(200번지)
              <------------------          request.getAttribute("xxx"); null 반환
	            6)응답

          - url이 변경됨. ( /xxx  --> a.jsp )
	  - 서블릿에서 request scope에 저장된 데이터는
	    리다이렉트된 jsp에서 참조 불가 (null 반환)
	    따라서 session scope 또는 application scope를 사용해야 된다.



     나. 포워드(forward)
        - HttpServletRequest 이용

	- 문법:
        
	 public class MainServlet extends HttpServlet{
	 public void doGet(HttpServletRequest request, HttpServletResponse response){

	     RequestDispatcher dis = request.getRequestDispatcher("a.jsp");
	                    dis.forward(request, response);

	 }
                                                      서버
               1) 요청
     웹브라우저 ------------------>    MainServlet("/xxx") 2) doGet실행
                                                    HttpServletRequest request(100번지) 생성
						     request(100번지).setAttribute("xxx","홍길동")
                                     |
				     |  3)포워드 위임(요청)
				         request.getRequestDispatcher("a.jsp")
				         dis.forward(request(100번지), response);
	    <--------------    a.jsp
  	                     <%
                                 request(100번지).
				 request(100번지).getAttribute("xxx")
			     %>
	==> forward 방식은 서블릿을 요청할 때 생성했던 request를 
	    jsp로 위임(요청)할때도 재사용한다.
	    따라서 하나의 request로 서블릿도 요청하고 jsp도 요청하는 방식으로서
	    request를 확장시킬수 있는 개념이다.
	==> 서블릿에서 request.setAttribute(key,value)로 저장된 데이터를
	    JSP에서 request.getAttribute(key) 하면 value를 얻을 수 있다.
	==> 브라우저 url 변경 안됨
	    서블릿맵핑값으로 계속 유지됨.


###################################################
4. MyBatis 연동


  1) SE 버전 아키텍쳐
                                 EmpService(인터페이스)
   JComponent04_JTextField <----> EmpServiceImpl    <-----------> EmpDAO <--------> MySQL
    (main메서드)

    - 2개의 jar파일을 build path로 설정.

  2) EE 버전 아키텍쳐 (***********)

				  EmpService(인터페이스)
브라우저->	    EmpListServlet  <----> EmpServiceImpl    <-----------> EmpDAO <--------> MySQL

		 |
		 |
	<---  list.jsp

   - 2개의 jar파일을 build path로 설정하지 않고
     WEB-INF/lib 폴더에 jar 복사한다.
     자동으로 build path됨.


######################################################
5일차

1. EL ( Expression Language )

  1) JSP의 구성요소
    - html
    - jsp 태그
        --> expression tag: <%= 값 %> <== 값을 브라우저에서 출력됨. <% out.print(값) %> 동일기능.
    - EL
    - JSTL ( EL과 같이 사용됨 )

  2) 문법:
     - ${표현식(값)|key}
      ==> servlet에서 scope에 저장할 때 사용된 key값임
  
  3) 기능 및 특징
     - 브라우저에서 출력됨
     - ${리터럴값} <== 리터럴값이 브라우저에 출력
       ${리터럴값+1} <== 산술연산 가능
       ${리터럴값>1} <== 비교연산 가능
       ${리터럴값>1 && 리터럴값 <20} <== 논리연산 가능

  
     - ${key}
       => 서블릿에서 scope에 저장할 때 지정한 key값으로서
          자동으로 key에 해당하는 데이터를 얻고 웹 브라우저에 출력함.

	 # 서블릿 작업
	  //1. request scope에 저장
	  request.setAttribute("userid", "홍길동");
	 
	 # JSP 작업

	   가. <% %> 이용
                <%
		   String userid = 
		       (String)request.getAttribute("userid");
		   out.print(userid);
		%><br>

	   나. %{key} 이용

	       ${userid}<br>

     - DTO 사용
           # 서블릿
	   request.setAttribute("user", new User("홍길동", 20));
         
	    
	   # JSP
               <%
		    User user=
		    (User)request.getAttribute("user");
		   String username=user.getUsername();
		   int age = user.getAge();
		%>
		이름:<%= username %><br>
		나이:<%= user.getAge() %><br>
		<hr>
		이름:${user.username}<br>
		나이:${user.age}<br>

     - List 사용

          # servlet
	    List<User> list = Arrays.asList(new User("홍길동1", 20),
					    new User("홍길동2", 30));
		
	    request.setAttribute("userList", list);

           # jsp

           <%
			   List<User> list =
			    (List<User>)request.getAttribute("userList");

			/*     User user1 = list.get(0);
			    User user2 = list.get(1); */
		    
		%>
		이름1:<%= list.get(0).getUsername() %><br>
		나이1:<%= list.get(0).getAge() %><br>
		이름2:<%= list.get(1).getUsername() %><br>
		나이2:<%= list.get(1).getAge() %><br>

		<hr>
		${userList}<br>
		이름1:${userList[0].username}<br>														
		나이1:${userList[0].age}<br>

		이름2:${userList[1].username}<br>
		나이2:${userList[1].age}<br>


      4) 명시적인 scope 지정

         <h1>EL3- scope에 저장된 데이터 출력시 명시적으로 scope지정</h1>
	request scope: ${requestScope.userid}<br>
	session scope: ${sessionScope.userid}<br>
	application scope: ${applicationScope.userid}<br>

2.  JSTL( Jsp Standard Tag Library )

  1) 개요
   - JSP에서 커스텀 태그를 사용하자.
   - 커스텀 태그 작성 방법
      java 클래스(IF.java) + 태그 정의서(TLD 파일, if태그정의)
       ==> *.class + *.tld
           ( *.jar )
     예> # jsp코드

         <if>                  public class IF{
	 
	                       }

	 </if>
    
     결론은 선배개발자 및 포털사이트등이 커스텀태그를 만들었을 것이다.
     1000개 --------> 추려서 표준(Standard)으로 제공했음. (Apache에서 제공한 커스텀 라이브러리를 사용할 것임)
                      이 표준화된 커스텀 태그를 JSTL이라고 부름.
		      JSTL에는 다양한 기능의 태그가 제공됨( 반복,조건,...)
                     정확히는 JSTL는 spec임.

   2) JSTL spec의 구현체 (Apache에서 제공)
    
     - jakarta.apache.org 에서 다운

       https://tomcat.apache.org/taglibs/standard/ 

       최신버전: Standard 1.2
       사용버전: Standard 1.1 (이유는 샘플제공,  standard-examples.war )

      
       압축풀고 lib 폴더에 가서 2개의 jar 파일을 
       생성된 웹 프로젝트 WEB-INF/lib 폴더에 복사한다.

   3) 사용방법

     가. lib 폴더에 가서 2개의 jar 파일 복사
     나. 서블릿 만들고 scope에 저장.
        ==> scope에 저장된 데이터를 EL+JSTL 이용해서 핸들링함.

     다. JSP 파일에서 <%@ taglib prefiex=""  uri="" %> 설정.

###########################################################################
3. 세션 관리 ( session tracking, 연결 관리) <== 클라이언트(웹브라우저)와 서버(tomcat) 연결관리

  1) HTTP 프로토콜 특징
     - connectionLESS
     - stateLESS
              a.요청
    브라우저 ----------------------> 서버 (b.요청에대한작업)
           <---------------------
	      c.응답
   d.화면랜더링(a.jsp)                   c 이후에 연결이 끊어짐
             e. 요청
           ------------------------> f.요청에대한작업
	   <---------------------
	      g.응답                  g 이후에 연결이 끊어짐
   h.화면랜더링(b.jsp)  


   2) 방법 2가지

    클라이언트                            서버
     브라우저                           a.jsp(데이터:홍길동)
                                      b.jsp


                                     서버에 저장: 세션
				               HttpSession 이용
                                               저장되는 데이터는 Object임(거의 모든 데이터 가능)
																# a.jsp 해야되는 작업 ( 데이터 저장역할)			                                 - HttpSession 얻기
											       					 # 세션이 있으면 반환하고 없으면 새로 생성해서 반환
				         HttpSession session = request.getSession();
					 HttpSession session = request.getSession(true);
                                         -----------------------------------------------
                                         # 세션이 있으면 반환하고 없으면 null 반환
					 HttpSession session = request.getSession(false);
				       
				       - 데이터 저장
				         session.setAttribute("x","홍길동");
					
				       # b.jsp 해야되는 작업 ( 데이터 사용 역할)
                                        - HttpSession 얻기
                                          HttpSession session = request.getSession();

					- 데이터 얻기
					 String n = (String)session.getAttribute("x");
					 if(n!=null){
                                             sysout(n.length); 
					 }else{
                                            //a.jsp를 거치도록 처리(로그인 작업을 먼저 하도록 처리)
					    response.sendRedirect("a.jsp");
					 }

			
					
				    
    클라이언트에 저장:쿠키
                 Cookie 이용
                 저장가능한 데이터는 문자열만 가능

##########################################################################
ShopMiniMall 프로젝트

* 환경정보
 - Servlet/JSP
 - MySQL + MyBatis ( shop DB 생성, shop/shop 계정생성, member/goods/cart/orderinfo 테이블 생성)
 - bootstrap ( https://getbootstrap.kr/ )
   설치는 CDN 방식 이용.
   CSS	https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css
   JS	https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js


1. 메인화면구축

  http://localhost:8090/shop/main

  웹브라우저 ----------> MainServlet ("/main")

                          | 요청위임(forward/redirect)

	 <----------    main.jsp  ( 전체화면임. webapp 폴더에 저장, 
	                             top.jsp, menu.jsp, 컨텐츠에 해당하는 jsp incldue함)


2. 회원가입화면 보기

웹브라우저 ----------> MembrUIServlet ("/signup")

                          | 요청위임(forward/redirect)

	 <----------    memberForm.jsp  ( 전체화면임. webapp 폴더에 저장,
	                                   top.jsp, menu.jsp, 컨텐츠에 해당하는 jsp incldue함)


3. id 중복체크 하기

 memberForm.jsp 에서        Ajax요청         ("/idCheck")      MemberService
 id입력후 [아이디중복]버튼 클릭 ----------> MemberIdCheckServlet--->MemberServiceImpl<--->MemberDAO
                         <----------
			  반환값(사용가능|사용불가)          MemberDTO.java
			  		            

 - member/memberForm.jsp 에 jQuery 설치
   <!-- jQuery 설치 -->
   <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>

 - mybatis 연동

   1) 2가지 jar 빌드패스
      WEB-INF/lib 폴더에 복사.
       mybatis-3.5.14.jar
       mysql-connector-j-8.3.0.jar

   2) jdbc.properties
      Configuration.xml
      MemberMapper.xml
      MySqlSessionFactory.java

4. 회원가입

- 사용자 입력 데이터 유효성체크 구현하기.
   
        post 요청          ("/MemberAddServlet")
저장 --------------------> MemberAddServlet -----------> MemberServiceImpl -------> MemberDAO
                            doPost처리.
			    request.setCharacterEncoding("utf-8");
			       |
	<----------------     jsp


5. 로그인 화면보기



웹브라우저 ----------> LoginUIServlet ("/login")

                          | 요청위임(forward/redirect)

	 <----------    loginForm.jsp 