
Servlet/JSP

1. 자바 개발 플랫폼

  1) Java SE ( Java Standard Edition)
      - 자바 spec.
      - JDK 설치로 SE 환경이 구축됨. 
      - rt.jar
      - 개발할 수 있는 프로그램 형태: 로컬로 실행되는 프로그램.

  2) Java EE ( Java Enterprise Edition)
      - Servlet/JSP spec. ( 인터페이스 개념 ) <=== 나중에 실제 구현체는 Apache의 Tomcat  서버가 제공
      - Tomcat 서버 설치로 EE 환경이 구축됨.
      - servlet-api.jar 와  jsp-api.jar ( 구현체 )
      - 개발할 수 있는 프로그램 형태: 웹브라우저를 이용하는 웹사이트 개발.

  3) Java ME ( Java Micro Edition )
     - 소규모 디바이스에서 동작하는 프로그램 개발
     - 예> 핸드폰, 셋탑박스, ...

2. 환경설정

  1) JDK 11
  2) eclipse
     - http://www.eclipse.org
     - JDK 11를 지원하는 이클립스를 사용해야 됨.
     - eclipse-jee-2022-06-R-win32-x86_64.zip

  3) Tomcat 서버
     - tomcat 9 버전 사용
     - http://jakarta.apache.org
     - servlet-api.jar 와  jsp-api.jar 지원됨.
       패키지명이 javax.servlet 형식으로 시작됨.
     - apache-tomcat-9.0.89.zip
     
       * Tomcat 10 
       패키지명이 jakarta.servlet 형식으로 시작됨.

 
3. eclipse 와 Tomcat 9 연동

  1) eclipse 실행

     - 인코딩 설정 ( UTF-8) 4개 확인

       general > workspace 에서 utf-8로 설정.

       web > css
             html    utf-8로 설정.
	     jsp 

     - JDK 11로 설정하기 (****************)
        preference > Java > Compiler  > 11로 변경.
        preference > Java > installed JRE > 기존 jre 삭제하고 
	           > Add 클릭 > Standard VM 선택 > JRE Home 에 C:\Program Files\Java\jdk-11 설정
		   > Finish > Applys Close
   
   2) eclipse에 Tomcat 9 설정해서 연동
	
      - Severs 탭에 추가된 tomcat 더블클릭하고 Overview 탭 선택 3가지 설정을 변경한다.
       가. server location 에서 Server Path 변경
          - 두번째 라디오버튼으로 변경. ( Use Tomcat installation )

       나. server location 에서 Deploy Path 변경
          - C:\servlet_study\apache-tomcat-9.0.89\webapps 설정.

       다. tomcat의 port 번호 변경
          - 8080 에서 8090로 변경
	   ( 변경하는 이유는 Oracle DB에 tomcat이 내장되어 있고 내부적으로 8080 사용함.
	     충돌방지하기 위해서 8090로 변경)

         * deploy path (배포 경로)
	 - 우리가 만든 웹 어플리케이션을 Tomcat 서버가 클라이언트에게 서비스를 제공한다.
	   이때 우리는 우리가 만든 웹 어플리케이션을 Tomcat 서버가 서비스할 수 있는
	   특별한 디렉토리에 저장해야 된다. 이 작업을 하기 위한 저장 경로를 배포 경로라로 부른다.

          - tomcat의 기본 배포경로는 C:\servlet_study\apache-tomcat-9.0.89\webapps
          - tomcat의 기본 port 는 8080 

   3) Tomcat 9 삭제 방법
 
      preference > Server >  Runtime Enviroments > 설정된 tomcat 삭제
     


4. 프로젝트 생성

  파일 > New > Dynamic Web Project 선택 

  project name: HelloTest

  web Module 화면

   1) Context Root
      - URL에서 사용
       http://localhost:8090/context명/자원(html,css,js,image,jsp,서블릿)
       - context명은 논리적인 이름으로
        실제 tomcat이 webapps (배포경로)에 저장하고 있는
	웹 어플리케이션을 선택하는 역할을 한다.
	내부적으로 다음과 같이 key/value로 구성됨.

	  context명   웹어플리케이션(webapps에 저장된 물리적인 디렉터리)
	  --------------------------
	    key        value
	  
	 예> a           x
	     b          y

        - context명 언제든지 변경 가능하고 대소문자 구별됨. ( 일반적으로 소문자로 사용)
	  단 반드시 / 로 시작해야 됨.


   2) Content Directory
      - 개발자가 만든 소스가 저장되는 디렉토리.
      - 이클립스의 workspace에 저장됨.
	예>
	
	eclipse의 project explorer 화면

	 HelloTest
	   ..
	   java Resources
	     src/main/java ( *.java 가 저장됨, 서블릿)
	     ..
	   src
	     main
	        java       ( *.java 가 저장됨 )
		webapp (*****)
		    META-INF
		      MANIFEST.MF
		    WEB-INF
		       lib
		       web.xml
		    
		    hello.html (정적)
		    test.css
		    test.js
		    test.png
		    world.jsp (동적)

         실행후 tomcat의 webapps 폴더에 배포된 디렉토리 구조는 다음과 같다.
          tomcat
	    webapps
	       HelloTest
                    WEB-INF
		       classes
		           com
			     dto
			       Person.class
			       서블릿
		       lib
		       web.xml
		    
		    hello.html 
		    test.css
		    test.js
		    test.png
		    world.jsp

		    

         * 3가지 컴포넌트
	 가. 정적 ( src/main/webapp 폴더에 저장 )
             - html ( *.html )
	     - JS
	     - CSS
	     - images
	 나. 동적
	     - jsp ( *.jsp ) <== html과 동일한 폴더에 저장. 즉 WEB-INF와 동일한 레벨
	                         html 처럼 비슷한 태그로 구성되었으나 자바코드를 포함할 수 있음.
	     - 서블릿(*.java) <== src/main/java 에 저장. 반드시 패키지로 작성해야 된다.(*****)

       =====> 최종적인 실행 결과는 html로 만들어져야 된다. (**********)


   3) web.xml
      - 배치 지시자 ( deployment descriptor )
      - 개발자가 만든 웹 어플리케이션의 전반적인 설정 정보 담당
       ( 예> filter 등록, 서블릿맵핑, ... )

       web.xml 대신에 어노페이션을 이용할 수도 있음.
    
       - Spring Framework에서 설정 정보를 web.xml로 사용함.

5. Tomcat 서버에 배포하는 디렉터리 구조 (********)

    webapps ( 배포경로의 홈디렉터리)
       폴더(HelloTest) <================== '웹 어플리케이션' 이라고 부른다.
             WEB-INF
	        classes
		    -*.class 저장
	        lib
		  - 나중에 mybatis.jar, mysql-connector.jar 같은 외부라이브러러 저장용
                web.xml 
 
	     *.html
	     *.js
	     *.css
	     *png



6. 클라이언트에서 웹브라우저에 요청하는 URL 문법 (******************)

 
  1) 정적 컴포넌트 요청 ( 디렉터리 없는 경우 )

   http://서버IP번호:port번호/context명/자원

   예> http://localhost:8090/xxx/hello.html        // 논리적인 context명인 /xxx
      http://localhost:8090/HelloTest/hello.html  // 물리적인 web application인 HelloTest 

      http://localhost:8090/xxx/test.css
      http://localhost:8090/xxx/test.js
      http://localhost:8090/xxx/tomcat.svg

   
  2) 정적 컴포넌트 요청 ( 디렉터리 있는 경우 ) <== 일반적인 구조
  
    http://서버IP번호:port번호/context명/디렉터리/자원

     http://localhost:8090/xxx/html/hello.html

     http://localhost:8090/xxx/css/test.css
     http://localhost:8090/xxx/js/test.js
     http://localhost:8090/xxx/images/tomcat.svg

  

   3) 동적 컴포넌트인 JSP 요청 ( 디렉터리 없는 경우 )

      http://서버IP번호:port번호/context명/자원

   예> http://localhost:8090/xxx/world.jsp   


   4) 동적 컴포넌트인 JSP 요청 ( 디렉터리 있는 경우 )

      http://서버IP번호:port번호/context명/디렉터리/자원

   예> http://localhost:8090/xxx/jsp/happy.jsp
   
  * html 동작 정리

          1)요청: http://localhost:8090/xxx/hello.html
    브라우저 ------------------------->   tomcat 서버 (8090)
                                           HelloTest ( 웹어플리케이션) <== 논리적인 이름 컨텍스트명:/xxx
					        WEB-INF
						hello.html

						2) hello.html 찾기
						   없으면 404 에러 발생
						   있으면 찾은 hello.html 다운
						   html은 서버에서 실행되지 않음. 그래서 정적(static)임.
          <-----------------------------------
	    3)응답: hello.html 다운
 4) 다운받고
   html 랜더링

   * JSP 동작 정리 ( 외우기 )
         1)요청: http://localhost:8090/xxx/world.jsp
   브라우저 ------------------------->   tomcat 서버 (8090)
                                           HelloTest ( 웹어플리케이션) <== 논리적인 이름 컨텍스트명:/xxx
					        WEB-INF
						world.jsp

						2) world.jsp 찾기
						   없으면 404 에러 발생
						   있으면 찾은 jsp를 변환한다.
						   (world_jsp.java 생성)
						3) world_jsp.java 컴파일 (컴파일 에러가 발생될 수 있음)
						   world_jsp.class 생성
					   4)  world_jsp.class 실행 (실행되기 때문에 동적 컴포넌트임)
                                             ==> 실행결과는 정적파일인 html로 나옴.
	    <---------------------------------
	       5) 응답: html 다운로드
 6) 다운받고
   html 랜더링

    * JSP 동작 3단계
      1) 변환단계
        world.jsp ---> world_jsp.java
      2) 컴파일 단계
      world_jsp.java --> world_jsp.class
      3) 실행단계
      world_jsp.class --> html



7. 서블릿(Servlet) 작성

  1) 저장 위치

     - src/main/java 
     - 반드시 패키지를 사용해야 됨.
     - servlet-api.jar 에 포함된 패키지를 사용.
       java EE API 문서 확인 가능.
       java.oracle.com 

  2) 문법 (*************)

      import javax.servlet.http.HttpServlet;	
	
    가. extends HttpServlet
    나. 서비스 메서드 재정의
       - 기본이 get 방식인 doGet()를 재정의하자.

    다. 서비스 메서드인 doGet() 안에서 html 작성해서 응답처리

    라. 서블릿 맵핑 (*************)
       ==> 서블릿을 요청하는 url의 별칭을 설정하는 방법이다.
       ==> 2가지 방식으로 설정할 수 있다.
           a. web.xml (*****, Spring 에서 사용하는 방식임 )
	   b. 어노테이션 ( @WebServlet("/별칭") )

     * 서블릿 맵핑 관련 

      OLD 방식: 현재 지원 안됨. 서블릿 맵핑 전 방식임.

             http://localhost:8090/컨텍스트명/servlet/패키지를포함한서블릿명
	
	   ==> HelloServlet 의 OLD 방식?
             
	     http://localhost:8090/xxx/servlet/com.servlet.HelloServlet

	   ==> 이슈 2가지 ?
	       - 매우 길다.
	       - 보안 취약.


      NEW 방식: 서블릿 맵핑
         
       
             OLD 방식:   http://localhost:8090/컨텍스트명/servlet/패키지를포함한서블릿명

	 서블릿 맵핑 방식:  http://localhost:8090/컨텍스트명/서블릿맵핑

	  @WebServlet("/hello") 로 설정했다면 다음과 같이 요청한다.

	  http://localhost:8090/xxx/hello

######################################################
정리

1. 환경설정
   jdk
   eclipse Enterprise 버전
   tomcat 9
     - servlet-api.jar
       jsp-api.jar

2. 3가지 컴포넌트
 
  1) 종류
   정적컴포넌트  : html

   동적컴포넌트  : jsp
               서블릿

  2) 저장위치
   
     src/main/java
                 서블릿(*.java)

     HelloTest
         WEB-INF
         *.html
	 *.jsp

 3) 요청 방법

    html 과 jsp 요청방법:

          http://localhost:8090/context명/html파일(jsp파일)
	  http://localhost:8090/context명/폴더/html파일(jsp파일)


    서블릿 요청방법:
          http://localhost:8090/context명/서블릿맵핑   (**************)


    * 서블릿맵핑2가지
      가. web.xml
      나. @WebServlet("/서블릿매핑")

   ==> 최종적으로 html로 응답된다. (***************)


4. 서블릿 작성방법

   1) extends HttpServlet
   2) 서비스 메서드 재정의 
      - doGet()
   3) 서비스 메서드에서  로직처리 및 html 작성후 응답
   4) 서블릿 맵핑
######################################################################
#####################################################################
2일차

1. 서블릿(Servlet)
   - servlet-api.jar 안의 패키지 이용
     javax.servlet.http 패키지의 HttpServlet 클래스 이용.
   - Java EE API 문서 참고.
     https://javaee.github.io/javaee-spec/javadocs/

   - HttpServlet 의 계층구조


       Servlet(인터페이스): init(),destory(),getServletConfig(),service(,) 
                      , ServletConfig(인터페이스):getInitParameter(String name),getServletContext() 
             |
             |  
       GenericServlet (추상클래스)
             |   :  service(,)
		   init(),destroy()
		   getServletConfig()
		   getServletContext()
		   getInitParameter(String name)
             |
       HttpServlet (추상클래스)
                 : doGet(HttpServletRequest request, HttpServletResponse response)
		   doPost(HttpServletRequest request, HttpServletResponse response)
		   doPut(,)
		   doDelete(,)
		   service(,)
		   init(),destroy()
		   getServletConfig()
		   getServletContext()
		   getInitParameter(String name)
             |
	     |
	 MyServlet (우리가 만들 서블릿 )
	     ==> extends HttpServlet 코드를 작업을 하면
	         웹브라우저의 요청을 처리할 수 있는 클래스가 된다.


     - 서블릿을 작성하는 순서
       1) extends HttpServlet
       2) doGet(HttpServletRequest request, HttpServletResponse response)
          또는 
          doPost(HttpServletRequest request, HttpServletResponse response)
	  메서드를 재정의.
	  기본 서비스 메서드는 doGet().
                 
		    요청(url입력,링크클릭,새로고침,버튼클릭...
		        submit )
	  웹브라우저 ------------------------------------> 서버
                        get요청 ------------------------> 서블릿의 doGet 요청처리
                        post요청 ------------------------> 서블릿의 doPost 요청처리

	       요청의 대부분은 GET 방식으로 요청됨.
	       POST로 요청하는 단 하나의 경우는?
	       <form method="post">

	3) doGet/doPost 메서드에서 비즈니스로 로직 처리하고 html 작성해서 응답처리.
	   - 요청처리(비즈니스 로직 처리)
             ==> 사용자의 요청처리( 폼데이터 처리 예> id/pw 얻기)
	     ==> 유효성 체크 ( DB 연동 )
	     ==> HttpServletRequest request 담당 ( 메서드가 처리 )

           - 응답처리
	     ==> 비즈니스 로직 처리에 대한 결과(id/pw 맞다/틀리다)를
	         사용자에게 알려주는 작업의미.
             ==> HttpServletResponse response 담당 ( 메서드가 처리 )

	4) 서블릿 맵핑
	  
	   - web.xml
	   - @WebServlet("/서블릿맵핑값")



2. 서블릿 맵핑 

    - web.xml
	    <servlet>
		<servlet-name>TestServlet</servlet-name>
		<servlet-class>com.servlet.TestServlet</servlet-class>
	    </servlet>
	    <servlet-mapping>
		<servlet-name>TestServlet</servlet-name>
		<url-pattern>/xxx3</url-pattern>
	    </servlet-mapping>

    - @WebServlet("/서블릿맵핑값") <== eclipse가 자동으로 지원 맵핑 방법


3. 서블릿 특징
 
   - main 메서드가 없다.( 시작점이 따로 없다는 의미)
    즉 사용자가 맨 처음 요청하는 서블릿이 시작점 역할을 담당한다.
   - 서블릿을 명시적으로 new(객체생성) 안함.
     Tomcat이 서블릿/JSP의 LifeCycle(생성~소멸)을 관리한다.
   - 서블릿은 단 한번만 생성됨. 
     thread-unsafe: 인스턴스변수 
     thread-safe: doGet의 로컬변수 (*****)

4. 서블릿의 LifeCycle 

  - 콜백 메서드가 제공됨.

  가. 서블릿 생성될 때 호출되는 콜백 메서드
    - init()
    - 용도: 서블릿이 생성될 때 초기화 작업 처리.
    - 중요: 
       서블릿은 단 한 번만 생성됨. 따라서 init() 메서드도 단 한번만 호출됨.
       따라서 서블릿에서 인스턴스 변수를 작성하면 여러 사용자들이 공유하게 됨.(보안에 매우 취약해짐)
            인스턴스 변수 사용은 권장안함.
       thread-unsafe 하다고 함.
       thread-safe하게 작성하는 방법은 doGet의 로컬 변수로 작성해야 된다.


  나.  서블릿 요청될 때 호출되는 콜백 메서드
    - doGet/doPost
    - 용도:  요청처리 와 응답처리

  다.  서블릿 소멸될 때 호출되는 콜백 메서드
     - destory()
     - 용도: 서블릿이 소멸될 때 clean up 작업 처리.


5.  서블릿의 응답처리
 
  - 응답처리 개념
    ==> 웹브라우저에서 볼 수 있도록 html 작성하는 처리의미.
  - 담당
    => doGet의 두 번째 파라미터인 HttpServletResponse 가 처리함.

  - HttpServletResponse 인터페이스의 메서드 확인

     response.addCookie(Cookie cookie): 쿠키 저장할 때 사용. 300개가 가능
     response.addHeader(String name, String value) : 응답 헤더에 헤더값을 추가할 때 사용.
     response.getHeader(String name) : 응답 헤더값을 얻을 때 사용.
     response.getStatus():           응답에 대한 status 값
    
     response.sendRedirect(String location): 서블릿에서 JSP로 위임할 때 사용.
     response.setContentType(String type)   :  웹 브라우저에게 처리할 데이터의 종류를 알려주는 기능.
                                               MIME 타입이라고 부름
					       Servers > web.xml 에서 종류 확인 가능.
					       예> text/plain : 일반 텍스트로 전달
					          text/html:   html로 전달
						  application/json: JSON으로 전달

     PrintWriter out = response.getWriter();
     out.print(값);  // 이 값이 웹 브라우저에 출력됨.

     System.out.println(값);  // tomcat의 console에 출력

    


     * 헤더 정보(header)

                     요청
		     (요청헤더가 전달됨)
		      method:get
		      Accept:text/html;~~~
		      Accept-Language: ko-kr,~
		      User_Agent: Mozilla~
     웹브라우저 ----------------------------> 서버
             <----------------------------
	            응답
		     (응답헤더가 전달됨)
		     Content-Type:text/html; charset=utf-8

 - 웹브라우저에 html 출력하는 방법

   가. MIME 설정
     response.setContentType("text/html");  // 한글처리: "text/html;charset=utf-8"

   나. html작성 출력
  
     PrintWriter out = response.getWriter();
     out.print("html코드");

  ==> 서블리에서 하는 응답처리는 쉽지않다.
     따라서 실제로는 서블릿에서 응답처리 하지 않음.
     대신 JSP에 위임해서 응답처리를 작업한다.

    예>
       1) 현재상황
                                      서버
       웹브라우저 ------------------>  서블릿
               <------------------

      2) 변경된 구조

                                     서버
       웹브라우저 ------------------>  서블릿
                                      |
                                      | 위임( 2가지 방법)
				          -response.sendRedirect(String location):
					  -request.getRequestDispatcher(String path):
               <------------------   jsp


6.  서블릿의 요청처리

  - 요청처리 개념
    ==> 웹브라우저에서 요청했을 때 서블릿에서 처리하는 작업의미.
       예> 사용자입력 데이터 얻기.
           한글처리
	   ..
  - 담당
    => doGet의 첫 번째 파라미터인 HttpServletRequest 가 처리함.

  - HttpServletRequest 인터페이스의 메서드 확인

     request.getContextPath() : 요청 URL에서 context명 얻을 때 사용.
     request.getCookies():      쿠키를 배열로 반환. Cookie[]
     request.getHeader(String name) : 요청헤더값 얻을 때 사용.
     request.getQueryString():    요청 URL에서 ?name=value&name=value
     request.getSession():      세션 얻을 때 사용. 매우중요(로그인시 사용됨)

     request.setAttribute(key,value);  // key/value쌍으로 데이터 저장할 때 사용
     request.getAttribute(key);        // key 이용해서 value 얻을 때 사용.
     
     request.setCharacterEncoding(String env):  "utf-8" 지정해서 한글처리 가능

     // 다음 4개이 메서드로 사용자 입력 데이터를 얻을 수 있다.
     request.getParameter(String name) :
      ==> 무조건 String 반환됨.
      ==> 일치하지 않는 name 지정하면 null 반환됨.
      ==> GET 방식으로 요청했을때 한글처리가 되서 한글이 잘 나옴.
      ==> POST 방식으로 요청했을때 한글처리가 안됨. 한글이 깨짐
           request.setCharacterEncoding("utf-8")

     request.getParameterNames():
     request.getParameterValues(String name):
     request.getParameterMap():

     request.getRequestDispatcher(String path):  서블릿에서 JSP로 위임할 때 사용.
     

  - 요청처리 실습하기 위한 구조
                                              서버
                1) jsp 요청
   웹 브라우저  ---------------------------->   memberForm.jsp ( 회원가입화면 )
             <----------------------------
	        2) 응답
  3) html랜더링
  id: aaa
  pw: 1234           4) 요청
  로그인버튼클릭 ----------------------------------> MemberServlet


7. 경로 
 
  1) 절대경로
    - / 로 시작.
    - 서블릿에서  / 는 다음 URL에서  8090 뒤의 / 를 의미한다.
     즉 / 를 기준으로 경로를 선택하는 방법이다.
 
     예> http://localhost:8090/app5/memberForm.html

        action="/login" <===  8090/login 의미.
	href="/~"
	src="/~"

  2) 상대경로
    - / 로 시작안하고 . 또는 .. 사용
    - 현재 URL에 보여지는 페이지의 경로를 기준으로 경로를 선택하는 방법이다.

8. 405 에러 

 - 발생되는 경우는 

    클라이언트의 method="get|post" 과  서블릿의 doGet|doPost 가 일치하지 않는 경우에 발생됨.

#############################################3
2일차 리뷰

1. 클라이언트에서 요청하는 4가지 작업


  클라이언트(사용자)  ------------------------->  MySQl 서버
                    select (Read)
		    insert (Create)
		    update (Update)
		    delete (Delete)


   클라이언트(사용자)      ------------------------------------->  Tomcat 서버
   method:GET|POST                                              서블릿
                                get(Read) ------------------>doGet
                                post(create,delete,update)--->doPost

   REST API:GET|POST|PUT|DELETE      get(Read) ------------------>doGet
                                     post(Create)---------------->doPost
				     PUT(update) ----------------->doPut
				     DELETE(delete) --------------->doDelete


2. HttpServletRequest 와 HttpServletResponse

            요청(GET:기본)                    서블릿
           - 사용자입력(폼데이터,파라미터)얻기
	  String userid = request.getParameter("name값");
웹브라우저 ------------------------------>  doGet(HttpServletRequest request,
                                                HttpServletResponse response){}
	<------------------------------
	    응답
	    response.setContentType("text/html;charset=utf-8");
	    PrintWriter out = response.getWriter();
	    out.print("html코드");
	    ==> 서블릿이 직접 html코드를 작성하는 작업은 매우 고된 작업이다.
                나중에는 JSP에게 위임해서 처리한다.

    *request 와 response 는 어떤 변수?
      - 로컬변수
      - 요청~응답 사이의 lifecycle를 가짐.
       따라서 첫번째 요청에서의 HttpServletRequest 와 
            두번째 요청에서의 HttpServletRequest 는 서로 다른다. (*****************************)