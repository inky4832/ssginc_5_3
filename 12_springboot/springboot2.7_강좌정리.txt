
Spring 어플리케이션 개발

1. Spring Framework 프로젝트
  - https://spring.io/projects/spring-framework#learn 가서 Reference Doc과 API Doc 참조.
  - 최신 버전인 6 는 JDK 17 부터 지원됨.
  - STS 3 사용해야 됨.

2. Spring Boot 프로젝트
  - https://spring.io/projects/spring-boot#learn 가서 Reference Doc과 API Doc 참조.
  - 최신 버전인 3 는 JDK 17 부터 지원됨.
  - STS 3 및 STS 4 모두 가능

3. 용어 정리

  1) POJO 
   - Plain Old Java Object
   - 플랫폼에 독립적인 형태의 클래스를 의미한다.
   예> CartListServlet는 의존적인 클래스( extends HttpServlet 때문에 Tomcat이 설치된 웹개발에서만 사용가능)
      CartDTO는 독립적인 클래스.

 2) (Spring) Bean
   - Spring 환경에서 사용되는 POJO 기반의 클래스 의미.
   - 개발자가 직접 Bean(클래스)을 new 하지 않음.
     Bean을 자동으로 관리하는 또 다른 Bean(IoC Container)이 제공됨.

    * Java Bean
     - Spring 이전에 사용되었던 이름.
     - EJB ( Enterpries Java Bean )에서 사용했던 명칭.
  

 3) IoC Container ( Inversion of Control Container: 제어의 역행)
   https://docs.spring.io/spring-framework/docs/5.2.25.RELEASE/spring-framework-reference/core.html#beans

   - 개념:
      IoC(Inversion of Control) 방법으로 Spring Bean을 관리(생성~소멸)하기 때문에 붙여진 이름

   - 비슷한용어:
     Spring Container
     Spring Context

   - 기능:
     Spring Bean을 관리(생성~소멸) 및 의존성 설정(DI:Dependency Injection: 의존성 주입).
     (이전 개발방식은 클래스를 직접 생성하고 의존성도 직접 설정했음.
      이런 순방향의 개발이 아닌 완전히 역방향의 개발이기 때문임.
      )

   - IoC Container의 실체는 Spring Bean이다. 계층구조로 되어 있음.

                    BeanFactory  ( 인터페이스 )
                          |                  |
	    XXXApplicationContext       XXXBeanFactory
                    |
            AnnotationConfigApplicationContext
	    GenericXmlApplicationContext
	    XXXWebApplicationContext ( web이 있는 것은 웹어플리케이션 개발용 IoC Container 임)

     BeanFactory: 기본 Spring Container 임.
     ApplicationContext : 기본기능 + enterprise 환경에서 필요한 전용기능이 추가된 컨테이너임
                                   ( 웹개발가능. I18N(국제화:InternationalizatioN), AOP 기능,.. )


  4) DI(Dependency Injection: 의존성 주입)

    - 의존성? A 클래스가 B를 사용하면 A와 B간에 의존성이 생김.
    - 의존성 주입? A(CartService)클래스가 B(CartDAO) 를 참조하기 위해서 외부(CartListServlet)에서 
                A 클래스의 생성자에 B 객체를 생성해서 설정하는 작업을 의미.

		Spring에서는 외부 역할을 IoC Container가 담당한다.

     - 의존성 주입 방법

       가. 생성자 이용한 주입
       https://docs.spring.io/spring-framework/docs/5.2.25.RELEASE/spring-framework-reference/core.html#beans-constructor-injection
       
       나. set메서드 이용한 주입
       https://docs.spring.io/spring-framework/docs/5.2.25.RELEASE/spring-framework-reference/core.html#beans-setter-injection



4. 빌드툴 (build tool)

 1) 개념
   - 개발시 사용되는 자동화 툴.

 2) 종류

   - Maven (메이븐)
      pom.xml ( 설정파일: jdk/boot 버전, 필요한 jar 파일들 설정)

   - Gradle (그레들) 
      build.gradle ( 설정파일: jdk/boot 버전, 필요한 jar 파일들 설정)


  3) 빌드툴 기능

    가. 이전 개발 프로세스

     소스코드작성 ----> 컴파일 ---> 테스트 파일작성(단위테스트) ->컴파일 ------> 패키징(jar/war) --->배포
             
	     필요한 외부 jar 다운
	       + 
             빌드패스
             <---------------------------------------------------------------------------->
	         개발자가 직접 수동으로 해줌.

    나. 빌드툴 적용한 개발 프로세스

      소스코드작성 ----> 컴파일 ---> 테스트 파일작성(단위테스트) ->컴파일 ------> 패키징(jar/war) --->배포
             
	     필요한 외부 jar 다운
	       + 
             빌드패스
              <----------------------------------------------------------------------------->
	                빌드툴이 거의 자동화해줌.


   4) Maven의 기본 디렉터리 구조

      src/main/java :  이전 이클립스의 src 경로와 동일.  *.java 저장
      src/main/resource:  *.java 제외한 나머지 파일들 저장.
                         예> jdbc.properties, EmpMapper.xml ( 이전에는 src 에 저장 )

      src/test/java :  단위 테스트 용도의  *.java 저장
      src/test/resource:  단위 테스트 용도의  *.java 제외한 파일 저장.

      JRE System Library : jdk 11 용 jar파일들 저장.
      Maven Dependencies : SpringBoot에서 사용해야 되는 jar파일들 저장.

        - junit( mockito ) 관련 jar: 단위 테스트 용도
        
	- logback(log4j, slf4j) 관련 jar:  로그출력 ( 로깅: logging )
	                          - 이제부터 System.out.println 더 이상 사용안함.

        - spring-beans, spring-core 관련 jar : Spring Framework

        - spring boot 관련 jar: Spring Boot 

    ===> 저장 경로는 C:\Users\ssginc76\.m2\repository 이다. (로컬 저장소)

       pom.xml ( Project Object Model )
       - 버전, 필요한 jar 정보등 설정
       - 계층구조로 구성됨. ( 부모에 해당하는 pom.xml 있음 )
       - 필요로 하는 jar 파일은 <dependency> 태그로 설정하면 자동으로 다운로드 되고 build path까지 해줌.
         http://mvnrepository.com


    5) Maven의 주요 기능

      가. 의존성 설정
        - pom.xml 에 필요로 하는 jar 파일은 <dependency> 태그로 설정하면 자동으로 다운로드 되고 build path까지 해줌.
	- http://mvnrepository.com 에서 <dependency> 정보를 얻을 수 있음.

     나. 빌드시 사용되는 단계별 명령어

          compile
	  test
	  package
	  install
	  deploy
	  clean

      


5. SpringBoot 프로젝트 생성 방법
 
  ==> 명시적으로 빌드툴 (build tool) 선택해야됨.
  ==> 
     STS 4 버전
       ==> pom.xml 파일의 <project>태그내의 값은 변경해야 된다.
       변경전: https://maven.apache.org/xsd/maven-4.0.0.xsd
       변경후: http://maven.apache.org/xsd/maven-4.0.0.xsd

     JDK: 11 버전
     SpringBoot: 2.7.18 버전

  1) STS에서 직접생성
    - STS에서 New > Spring Starter Project 선택

  2) Spring Initializer 이용한 방법
     - 웹에서 생성후 다운받아서 사용함.
      http://start.spring.io


6. IoC Container에게 빈정보 같은 데이터를 알려주는 방법 ( Configuration 작업 )

  1) XML 이용
  2) 어노테이션 + 약간의 XML
  3) 어노테이션 <== Java Configuration 이라고 부름.

  4) boot ( xml 기반가능, 어노테이션 + 약간의 XML 가능, 어노테이션 가능(기본))
    ==> src/main/resources 의
       application.properties 이용해서 전반적인 환경설정을 설정함.

#############################################################
2일차

1. Spring Boot 등장배경

  - 2016년에 등장.
  - 기존의 framework에서는 개발자가 처리해야 되는 많은 설정이 있었기 때문에
    매우 설정( Configuration 작업 )자체가 복잡했음.
    실제 비즈니스 로직에 집중하지 못함.
    이러한 문제를 해결하기 위해서 Spring Boot 라는 서브 프로젝트가 진행됨.
     Spring Boot 는 많은 설정들을 자동화해서 개발자가 실제 비즈니스 로직에 집중하도록 도와줌.

2. Spring Boot 장점(특징)

  - 설정 자동화
      pom.xml에 의존성 설정하면 자동으로 지정된 의존성에 맞는 환경을 설정해줌.

  - 라이브러리 자동 관리
      maven + starter 
  
  - 웹어플리케이션 프로젝트인 경우에도 jar 실행가능.

    * 어플리케이션 개발후 배포 방법
     
     1) 비웹 어플리케이션
         - 일반적인 Java SE 환경: jar
	 - Spring Framework 환경: jar
         - Spring Boot 환경: jar

     2) 웹 어플리케이션
	 - 기본 Servlet/JSP 환경: war
	 - Spring Framework 환경: war
         - Spring Boot 환경: jar/war

          jar 실행: java -jar  파일명.jar

   - boot 프로젝트의 설정 정보는 src/main/resources 의
     application.properties ( applicaion.yml 야물) 이용해서 전반적인 환경설정을 설정함.

    # application.properties
      server.error.whitelabel.enabled=false
      server.port=8090
 
    # application.yml
      server:
	  error:
	    whitelabel:
	      enabled: false
	      
	  port: 8090
 
3. Spring Boot Starter
https://docs.spring.io/spring-boot/docs/2.7.18/reference/htmlsingle/#using.build-systems.starters

  1) stater 개념
   - 필요한 jar 파일들의 묶음.
     
  2) 참조 사이트
   http://mvnrepository.com 에서 starter 사용가능.


4. XXXXApplication.java 
https://docs.spring.io/spring-boot/docs/2.7.18/reference/htmlsingle/#getting-started.first-application.code.spring-boot-application

    @SpringBootApplication
    public class Application{

        public static void main(String[] args) {
		SpringApplication.run(DemoApplication.class, args);
	}
    }

  - 위 코드는 spring boot에서는 필수코드임.
  - 시작점 역할 담당.
  - @SpringBootApplication 어노테이션 필수로 지정.
    다음 3가지 어노테이션을 포함한다.

    @SpringBootConfiguration
      - 개발자가 필요에 의해서 추가적인 Configuration 설정할 수 있도록 지원.
        (추가적인 설정방법: 클래스 작성하고 @Configuration 지정 )
      - 대표적으로 Spring Security 임.
       예>
          @Configuration
	  public class MyConfiguration{
               // 코드
	  }
    @EnableAutoConfiguration
      - pom.xml에 stater같은 의존성을 설정하면 거의 자동으로 필요한 설정을 해줌.
        즉 자동 구성 메커니즘 활성화.
      - 예> spring-boot-starter-web 지정하면 자동으로 tomcat 설치되고
           404 발생시 자동으로 Whitelable ~ 페이지를 제공하는 등..

    @ComponentScan
      - 자동으로 빈생성하는 방법으로 기본적으로 패키지 단위로 설정해서 
        자동으로 생성하도록 가이드함.
     
      - scan 방법 2가지

        가. 패키지를 지정하지 않는 경우의 scan
 
          - @SpringBootApplication 가진 Application.java의 패키지와 
	    같거나 서브 패키지로 작성하면 자동으로 scan 됨. ( 권장 방법 )

	나. 패키지를 지정한 경우의 scan
	  - 명시적으로 생성할 빈의 패키지명을 알려줘야 된다. 
	    예> @SpringBootApplication(scanBasePackages = {"com.exam2"})

 

###############################################################################3
5. 로깅처리
https://docs.spring.io/spring-boot/docs/2.7.18/reference/htmlsingle/#features.logging

# 로깅레벨에 따른 색상설정시 never 동작안되는 상태 참조
https://stackoverflow.com/questions/48011632/where-is-spring-output-ansi-enabled-configured

  1) 개요
   - System.out.println 대신 특정 값(로그값)을 상황(레벨)에 맞게 콘솔(파일)에 출력.

  2) 로그처리를 전문적으로 해주는 라이브러리

     - log4J 라이브러리 
     - logback 라이브러리 ( boot 기본 로깅 담당 ) 
     - ..

     * 로깅처리 구조

         SLF4J ( 인터페이스, 스펙 ) - log()
          |
          | 구현
      log4J   logback

  3) 로깅레벨

       trace
       debug
       info ( 기본 )
       warn
       error
  
    ==> application.properties 에 로깅레벨을 설정.
    ==> 동작방식은 지정된 레벨 포함한 하위 레벨까지 로깅처리됨. 

  4) boot에서 로깅처리를 담당하는 의존성이 있음
  
     spring-boot-starter 의 서브로
         spring-boot-starter-logging 이 담당
	          log4J
		  logback
		  slf4j

 
  5) 적용
    
    가. application.properties 에 로깅레벨을 설정.
   
      문법:
        logging.level.관심있는패키지명=로그레벨

      # 로깅레벨
      logging.level.org.springframework=debug
      logging.level.com.exam=info
 
      # 파일에 저장1- 경로지정만 함.
      logging.file.path=c://log   ( spring.log 파일이 생성됨 )

      # 파일에 저장2 ( 경로지정 + 파일명 같이 지정 )
      logging.file.name=c:\\temp\\test2.log	

   6) 사용자 지정 로그 출력

      # application.propertis
        logging.level.com.exam=trace


      # java
      import org.slf4j.Logger;
      
      Logger logger = LoggerFactory.getLogger(getClass());


      //로그 출력
	logger.trace("trace:{},{}", "trace1","trace2");
	logger.debug("debug:{}", "debug");
	logger.info("info:{}", "info");
	logger.warn("warn:{}", "warn");
	logger.error("error:{}", "error");

####################################################
6. 빈 생성 방법

  - 항상 Application.java의 패키지와 같거나 서브 패키지로
    빈을 작성하자. (***********************************)

  1) 명시적으로 생성
     - @Configuration + @Bean 이용
     ==> @Configuration 을 통해서 @Bean으로 지정한 빈을 생성했음.
     ==> @Bean 은 메서드 레벨만 가능.
         @Configuration 는 클래스 레벨만 가능.

  2) 다른 패키지로 되어 있는 경우
      - 명시적으로 패키지를 알려줘야 됨.
      - @SpringBootApplication(scanBasePackages = {"com.exam2"})
        public class Application {

  3) 자동으로 생성 (권장 패키지 구조)
  https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.structuring-your-code.locating-the-main-class

    첫번째 작업: @SpringBootAppliction와 같은 패키지이거나 서브 패키지로 작성한다.
    두번째 작업: 클래스에 어노테이션을 지정한다. 
              @Configuration,@Component,@Repository,@Service,@Controller,@RestController

     com.exam
        
	@SpringBootAppliction ( , , @ComponentScan)
	Application.java

              xxx
	        @Configuration ( 빈으로 생성됨) - @Bean으로 빈 생성시 빈정보를 설정하는 빈에서 사용.
	          Test.java
                @Component ( 빈으로 생성됨) <-- 범용적으로 사용
		  Hello.java
                @Repository ( 빈으로 생성됨) <---- DAO 역할의 빈에서 사용
		  World.java
		@Service ( 빈으로 생성됨)    <---- Service 역할의 빈에서 사용
		  World2.java
		@Controller ( 빈으로 생성됨)   , @RestController ( 빈으로 생성됨) 
		  World3.java

                  World4.java
    com.exam2
              yyy
	        @Component
	        Main.java
              


7. 의존성 설정

  - 구조

      DeptService
      @Service                        @Repository
      DeptServiceImpl ---------------> DeptDAO

      DeptDAO dao;
      public DeptServiceImpl(DeptDAO dao){
         this.dao = dao;
      }

  1) 묵시적으로 설정 방법

    가. 생성자 이용 (권장방법)
      DeptDAO dao;
      EmpDAO dao2;

      public DeptServiceImpl(DeptDAO dao, EmpDAO dao2){
         this.dao = dao;
	 this.dao2 = dao2;
      }
  
      - 권장방법
        권장이유는 하나의 블럭에서 모든 주입이 완료됨.
	         또한 주입받는 시점이 생성시점이기 때문에 @Autowired 보다 훨씬 빠름.
      - 기본생성자는 반드시 없어야 됨.


    나. 어노테이션 이용
      - @Autowired 
 
      예> 
        @Autowired
	DeptDAO deptDAO;

	@Autowired
        EmpDAO dao2; 

  2) 명시적 설정 방법
    - skip


  3) 주입 가능한 타입이 여러개 인 경우
   - 기본적으로 에러가 발생됨.
   - 해결:
         @Primary
	 또는
	 @Qualifier("빈이름")

      예>
         @Repository("empDAO")
	 @Primary
         public class EmpDAO


        // 생성자 주입 이용
	public DeptServiceImpl(@Qualifier("deptDAO")   CommonDAO commonDAO) {}


        // @Autowired 이용
        @Autowired
	@Qualifier("empDAO")
	CommonDAO commonDAO;

  
    4) 생성자 주입과 @Autowired 혼합 가능




8. 생성된 빈 접근하는 방법

  ApplicationContext ctx;

  public 생성자(ApplicationContext ctx){
     this.ctx = ctx;
  }

  또는
 @Autowired
 ApplicationContext ctx;

  ctx.getBean("xxx", 클래스명.class);  // @Service("xxx") public class DeptServiceImpl



9. 빈의 scope 

  1) 개념
    빈 생성후에 ctx.getBean() 를 여러번 했을 때 반환되는 빈의 스코프를 의미한다.
    기본적으로 bean은 한번만 생성되고 getBean()을 여러번 했을 때 동일한 인스턴스를 반환함. ( 싱글톤 )

    예>
        DeptServiceImple s = ctx.getBean("xxx",DeptServiceImple.class);
	DeptServiceImple s2 = ctx.getBean("xxx",DeptServiceImple.class);


   2) scope 값 종류

     @Scope(value=상수값)
     예> @Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
        @Scope("singleton") 
        @Scope(value = ConfigurableBeanFactory.SCOPE_SINGLETON) // 기본
        @Scope("prototype") 

    - singleton ( 기본, 단 하나의 빈으로 서비스, thread-unsafe )
    - prototype ( getBean 할 때 마다 매번 생성해서 서비스, thread-safe )

    - request ( web 사용가능.  요청~응답 사이에서만 사용 가능 )
    - session ( web 사용가능.  기본적으로 web브라우저가 open 되어있는 동안 사용 가능 )
    - application ( web 사용가능.  기본적으로 Tomcat컨터네이가 start 되어있는 동안 사용 가능 )

10. 초기화 및 cleanup 작업 처리
https://docs.spring.io/spring-framework/docs/5.2.25.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle

  1) 개요
   - 빈(bean)이 생성되고 의존성 주입(DI) 이후의 
     필요한 초기화 작업 및 자원반납 작업 처리가 가능하도록 지원.

  2) @PostConstruct 와  @PreDestroy  이용

   예>
      @PostConstruct
      public void init(){
          //초기화작업
      }

      @PreDestroy
      public void clean(){
          //cleanup작업
      }

11.  프로파일( Profile )
https://docs.spring.io/spring-boot/docs/2.7.18/reference/htmlsingle/#features.external-config.files.profile-specific

   1) 개요
    - 실제로 개발할 때는 개발환경, Q/A 환경, .. ,  production환경
      다양한 환경을 개발자가 선택적으로 정해서 환경을 맞출 수 있는 개념.
 
    예>
       # 개발환경

       Application.java -------> DeptServiceImple ------>DeptDAO ------> H2(데이터베이스,인메모리)
   

       # production환경

       Application.java -------> EmpServiceImple ------>EmpDAO ------> MySQL(데이터베이스)

    2) profile 에 따라서  properties 파일 선택 방법 
    
      여러 개의 application.properties 필요

      문법: 
          application-프로파일명.properties (yml)

       - application.properties ( 기본 )
           # 동작할 프로파일명 지정
	   spring.profiles.active=prod  <== 지정한 프로파일명에 해당하는 
	                                     application-프로파일.properties가 실제로 실행됨.

         application-dev.properties  ( 개발용 )
         application-prod.properties  ( product용 )	


  3) profile 에 따라서  빈(bean) 파일 선택 방법

     application.properties ( 기본 )
           # 동작할 프로파일명 지정
     spring.profiles.active=prod


     @Profile("dev")
     public class DevBean{}

      @Profile("prod")
     public class ProdBean{}


    OOP ( Object Oriented Programming: 객체 지향 프로그래밍 )
12. AOP ( Aspect Oriented Programming: 관점 지향 프로그래밍 )
https://docs.spring.io/spring-framework/docs/5.2.25.RELEASE/spring-framework-reference/core.html#aop
   1) 개념
    
     브라우저 ----------------> A서블릿 -----> 서비스 -----> DAO ------> DB
                             (핵심기능:필수)     (핵심기능)    (핵심기능)
			       +             +          +
			      부수기능:로깅)  부수기능:로깅)    부수기능:로깅)
			      
    브라우저 ----------------> B서블릿 -----> 서비스 -----> DAO ------> DB
                             (핵심기능)     (핵심기능)    (핵심기능)
			                    +          +
			                   부수기능:로깅)    부수기능:로깅)


    - 각 layer가 달라도 공통적으로 사용되는 코드들이 있음(부수기능).
      예> 로그처리

    
    - 최종적인 AOP 개념은 다음과 같다.
      핵심기능과 부수기능(공통기능)을 분리하고 필요시 부수기능을 주입 받아서 구현하는 개발 방법론 의미.

    
    2) AOP 기술

      가. AOP 원천기술
         - AspectJ ( 1995년 )
	 - 굉장히 무겁다.
	   startup 시간이 많이 걸림.
         - target class의 많은 이벤트가 발생시 AOP 적용될 수 있다.
	   예> 변수값이 변경,
	      생성자 호출,
	      메서드 호출,
	      ...

      나. Spring AOP
        - 원천기술인 AspectJ에서 일부분의 기술만 빌려와서 만듬.
	- Spring 기반의 AOP 프레임워크.
        - target class에서 메서드 호출(*****)되는 이벤트에서만 AOP가 적용됨.



     3) 용어정리
     
      가. Aspect
         - 여러 빈에 공통적으로 사용되는 부수기능을 구현한 빈을 의미.
	 - @Aspect 어노테이션 사용

      나. JoinPoint
         - 핵심기능에 Aspect가 적용되는 시점을 의미.
	   Spring AOP에서는 메서드 호출되는 시점만을 의미한다.

	 - 이벤트로 적용됨.
	 예> 핵심기능에서 발생 가능한 이벤트 종류?
	   
	    # 핵심기능 ( 타겟클래스: target class )
	    @Service
	    public class DeptServiceImpl{

                 int num;  // 값 변경 이벤트

		 public void setNum(int n){} // 메서드 호출 이벤트
		 public int getNum(){}     // 메서드 호출 이벤트
		 public DeptServiceImpl(){} // 생성자 호출 이벤트
		 ..
	    }


            # 부가기능(로깅처리)
	    @Aspect
	    public class MyAspect{

	        public void log_print(){
                  s.o.p("로그출력");
		}

	    }

       다. PointCut
       https://docs.spring.io/spring-framework/docs/5.2.25.RELEASE/spring-framework-reference/core.html#aop-pointcuts-examples
          - JoinPoint는 AOP가 주입되는 시점인 메서드 호출시점을 의미하고
	    PointCut 는 메서드들 중에서 어떤 메서드를 호출했을 때 주입할 것인지를
	    알려주는 표현식이다.

          - execution("public int getNum()")
	    execution("public int get*()")
	    execution("public * get*()")
	    execution("public * get*(**)")
	 
	라.  Advice
           - JoinPoint는 AOP가 주입되는 시점인 메서드 호출시점을 의미하고
	      PointCut 는 메서드들 중에서 어떤 메서드를 호출했을 때 주입할 것인지를
	      알려주는 표현식이고
	      Advice 호출된 메서드 전/후/성공/에러/(전,후,성공,에러)/ 시점을 의미.

	      전: @Before
	      후: @After 
             성공: @AfterReturning
	     실패: @AfterThrowing
             (전,후,성공,에러): @Around  

	   예>

	       # 사용

	       DeptServiceImpl service = ctx.getBean();

	       //전
               int n = service.getNum();
               //후

    마. weaving
      - target object 와 aspect 연결의미.


  4) 구현

    가. 의존성 설정
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-aop</artifactId>
	</dependency>
	
	==> aspectjweaver-1.9.7.jar 다운로드됨.

    나. Aspect 작성
      - 부가기능을 구현한 빈
      - @Aspect 어노테이션 지정


    다. Aspect 내에서 advice와 pointcut 을 설정

      - @Before(pointcut설정)
         - target object의 필수기능인 메서드가 호출하기전에 위빙
         예> @Before("execution(public * say*(..))")

      - @After(pointcut설정)
         - target object의 필수기능인 메서드가 호출하기후에 위빙
         예> @After("execution(public * say*(..))")


       - @AfterReturning(pointcut=pointcut설정, returning=리턴값저장변수설정)
        https://docs.spring.io/spring-framework/docs/5.2.25.RELEASE/spring-framework-reference/core.html#aop-advice-after-returning

          - target object의 필수기능인 메서드가 리턴한 값을 얻을 수 있다.
          예> 
	  @AfterReturning(pointcut="execution(public * say*(..))", returning = "xxx")
	public void afterLogging(JoinPoint join, Object xxx) {

   
        - @AfterThrowing(pointcut=pointcut설정, throwing=발생된예외저장변수설정)
	    - target object의 필수기능인 메서드가 예외발생 되었을 때
	    예>
	    @AfterThrowing(pointcut="execution(public * say*(..))", throwing = "ex")
	    public void afterThrowingLogging(JoinPoint join, Exception ex) {

      - @Aroud(pointcut설정)
        
	   - @Before + @After + @AfterReturning + @AfterReturning 모두 포함하는 기능
           예>
	       public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {
      
			Object retVal = pjp.proceed();

			return retVal;
               }

    5) AOP 패턴

      가. Pointcut 정의한 빈 작성
         public class CommonPointcutConfig {

		@Pointcut("execution(public * say*(..))")
		public void businessService() {}
		
		@Pointcut("execution(public * aa*(..))")
		public void businessService2() {}
	}


      나. Aspect에서 빈의 메서드 호출래서 pointcut 적용

##############################################################

13. Spring 기반의 DB 연동

  1) JDBC vs Spring JDBC
     - sql 이용
     - JDBC보다 자바코드가 훨씬 적음. ( 예외처리 불필요. 이유는 모두 RuntimeException 계열임 )
      
         try{

	 }catch(SQLException e){
           throw new RuntimeExceptino("");
	 }
     - JdbcTemplate 빈을 이용해서 DB 처리.

  2) Spring JDBC + h2 연동

     가. 의존성 설정
                <dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jdbc</artifactId>
		</dependency>
		<!-- https://mvnrepository.com/artifact/com.h2database/h2 -->
		<dependency>
		    <groupId>com.h2database</groupId>
		    <artifactId>h2</artifactId>
		    <scope>runtime</scope>
		</dependency>

     나. h2 관리자 콘솔 설정 
       - 웹페이지로 제공
       - 의존성 설정
           	<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

       - h2 관리자 콘솔 활성화
         # application.properties
	   spring.h2.console.enabled=true

       -  Application.java 실행 
        다음과 같이 console에 h2 관리자 정보가 출력됨.
	H2 console available at '/h2-console'. 
	Database available at 'jdbc:h2:mem:619f31a9-e3f7-4ccc-92ec-b6a360f8c1ab'

H2 console available at '/h2-console'. 
Database available at         'jdbc:h2:mem:aeed695e-ecd0-4049-be58-b89a1902d11c'

        웹 브라우저에 요청
	http://localhost:8080/h2-console

	요청 URL은 실행시마다 매번 랜덤하게 바뀜.
	따라서 URL 고정하자. ( testdb )
        # application.properties
         spring.datasource.url=jdbc:h2:mem:testdb

     다. 매 실행마다 자동으로 파일 인식해서 테이블 생성 + 데이터 저장하는 작업 처리 
https://docs.spring.io/spring-boot/docs/2.7.18/reference/htmlsingle/#howto.data-initialization.using-basic-sql-scripts	

      # src/main/resources 
       schema.sql : create table 문 
       data.sql   : insert 문


       # schema.sql
         create table todo(
	 id int primary key,
	 name varchar(255) not null,
	 author varchar(255) not null);

       # data.sql
        insert into todo (id,name,author) values(1, 'boot공부','홍길동');
	insert into todo (id,name,author) values(2, 'react공부','홍길동');
	insert into todo (id,name,author) values(3, 'CI/CD공부','홍길동');


     라. boot와 연동
 
        - 전체적인 아키텍쳐
                              TodoH2Service
			      @Service                 @Repository
       Application.java <-->  TodoH2ServiceImple <-->  TodoH2Repository <----> h2
                                                       TodoDTO(Todo)
        
        - sql문 + JdbcTemplate 빈 이용해서 연동
	  DML(insert/delete/update): update() 메서드
	  단일레코드조회:                queryForObject(sql, RowMapper인터페이스, 파라미터값)
	  다중레코드조회:                query(sql, RowMapper인터페이스 [, 파라미터값])


  3) Spring JDBC + mysql 연동

     가. 의존성 설정
                <dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jdbc</artifactId>
		</dependency>
		<!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->
		<dependency>
		    <groupId>mysql</groupId>
		    <artifactId>mysql-connector-java</artifactId>
		    <version>8.0.33</version>
		</dependency>

      나. DB 연동위한 4가지 정보 설정
        #application.properties
	spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
	spring.datasource.url=jdbc:mysql://localhost:3306/testdb
	spring.datasource.username=root
	spring.datasource.password=1234


      다. schema.sql 과 data.sql 활성화
      https://docs.spring.io/spring-boot/docs/2.7.18/reference/htmlsingle/#howto.data-initialization.using-basic-sql-scripts

        #application.properties
	spring.sql.init.mode=always|never

  4) mybatis + mysql 연동1 - @Repository 클래스 + TodoMapper.xml 연동

      가. 의존성 설정

		<!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter -->
		<dependency>
		    <groupId>org.mybatis.spring.boot</groupId>
		    <artifactId>mybatis-spring-boot-starter</artifactId>
		    <version>3.0.3</version>
		</dependency>
		<!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->
		<dependency>
		    <groupId>mysql</groupId>
		    <artifactId>mysql-connector-java</artifactId>
		    <version>8.0.33</version>
		</dependency>


        나. DB 연동위한 4가지 정보 설정
        #application.properties
	spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
	spring.datasource.url=jdbc:mysql://localhost:3306/testdb
	spring.datasource.username=root
	spring.datasource.password=1234


	다. TodoDTO.java

	라. TodoMyBatisMySQLRepository.java

	   a. 이전 버전

	    Service 클래스                    DAO 클래스
            SqlSession 얻기  <--------------->  SqlSession 사용
	                     SqlSession 전달
	    트랜잭션 처리(***)
	    close()

	  ==> Service클래스에서 SqlSession을 얻은 이유는 트랜잭션(transaction) 처리 때문이다. (*******)
              트랜잭션(transaction) 처리는 session.commit()/session.rollback() 으로 처리함.
	   
	   b. Spring 
            ==> 이전 버전의 SqlSession 역할하는 빈이 제공됨. ( SqlSessionTemplate )


             Service 클래스                    DAO 클래스

	                                      SqlSessionTemplate 얻기

	    @Transactional 
	    public void tx(){
		
		insert();
		delete();

	    }

	  @Transactional 동작방식
	   - insert()와 delete() 모두 성공하면 자동으로 commit 해줌.
	   - insert()와 delete() 작업중 하나라도 RuntimeException 발생되면 자동으로 모두 rollback 해줌.


      마. TodoMyBatisMySQLService.java
          TodoMyBatisMySQLServiceImpl.java
        


      바.  src/main/resources 
                             com.exam.config
			                     TodoMapper.xml

      사. 별칭과 mapper 등록

        # application.properties
	# 별칭
	mybatis.type-aliases-package=com.exam.dto
	# mapper 등록
	mybatis.mapper-locations=com/exam/config/*Mapper.xml


    5) Spring framework 및 Spring boot 트랜잭션 처리

       - Service 빈에서 @Transactional 어노테이션으로 트랜잭션 처리한다.
       - @Transactional 

           클래스 레벨:  클래스내의 모든 메서드가 트랜잭션 으로 처리됨.

	   메서드 레벨:  지정된 메서드에서만 트랜잭션 으로 처리됨.

 ################################################################

    6) mybatis + mysql 연동2 (***) - @Mapper 인터페이스( TodoMapper.java ) + TodoMapper.xml 연동

      가. 기존 repository 삭제
      나. com.exam.config.TodoMapper.xml 과 동일하 위치에
                          TodoMapper.java 인터페이스 작성.

      다. TodoMapper.xml 의 namespace 값과 TodoMapper 인터페이스 경로와 반드시 일치해야 된다.
          <mapper namespace="com.exam.config.TodoMapper">

      라. TodoMapper.java 인터페이스에 @Mapper 어노테이션 지정.
      마. TodoMapper.java 인터페이스의 메서드명과 TodoMapper.xml의 id와 반드시 일치해야 된다.

/////////////////////////////////////////////////////////////////////////////
14. Spring MVC

 1) MVC 아키텍쳐

  가. 서블릿/JSP MVC 아키텍쳐 ( Model 2 Architecture )


    웹 브라우저 -------> 서블릿(개발자가 구현) ---------> Service -------> DAO ------> DB
                      ListServlet (/list)
		      AddServlet (/add)
                           |
			   | <== 요청위임(redirect/foward)
			   \/
			 jsp 
		           

   ListServlet 까지 올려면 요청 URL?
   http://서버IP:port/context명/서블릿매핑
   http://localhost:8090/context명/list
   http://localhost:8090/context명/add

   ListServlet 했던 주요한 작업들 ?
     - 요청처리
        예> request.getParameter("name");
	   ...
     - 응답처리
        예> 직접 응답 또는 jsp 위임작업

   * 요청 위임
     - redirect 방식

     - foward 방식
 
#######################################################################
  나. Spring MVC 아키텍쳐

                                    
    웹 브라우저 ----> 서블릿(spring 제공) ---> Controller ---->Service ----> Repository ----> DB
                   DispatcherServlet(/)      /list 역할
                  Mapping servlets: dispatcherServlet urls=[/]
		   	                     /add 역할
                                    <---
				    jsp + jsp에서보여줄데이터 ( 응답처리 )
			  |
			  | <== 요청위임(redirect/forward)
			jsp 

   DispatcherServlet 까지 올려면 요청 URL?
   http://서버IP:port/context명/서블릿매핑
   http://localhost:8090/context명/
      
   ====> 404이기 때문에 White Label page가 보임.

    Controller 까지 올려면 요청 URL?
   http://서버IP:port/context명/서블릿매핑/요청맵핑값  (******************)
   http://localhost:8090/context명/list
   http://localhost:8090/context명/add

   DispatcherServlet 에서는 
   이전 ListServlet에서 했던 요청처리 및 응답처리를
   직접 구현할 수 없다.
   따라서 다른 클래스(Controller)를 이용해서 이전 서블릿에서 
   했던 작업들을 구현한다.

 
 2) Spring MVC 실습

  가. 의존성 설정
     
      <dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-web</artifactId>
      </dependency>
      <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-devtools -->
	<dependency>
	    <groupId>org.springframework.boot</groupId>
	    <artifactId>spring-boot-devtools</artifactId>
	</dependency>


  나. port 번호 및 context 명 변경

     # application.properties
        # tomcat port 번호 변경
	server.port=8090

	# context 명 변경
	server.servlet.context-path=/app

   요청은 http://localhost:8090/app/ 이고 whitelabel error page 보임.
    
        /app : context명
	/    : 서블릿맵핑명


   다. Controller 작성
    
      - 이전 서블릿/jsp 버전의 서블릿 역할 담당. ( 요청처리 및 응답처리 )
      - POJO 기반
      - 빈으로 자동 생성될 수 있도록 권장 패키지 구조를 준수 + @Controller 로 지정.
      - 요청 url과 일치하는 요청맵핑값을 설정. 
        반드시 유일한 값으로 지정 필수.

       예>  http://localhost:8090/app/list  <== list 역할의 메서드 실행
           http://localhost:8090/app/add    <== add 역할의 메서드 실행


       문법:
            @RequestMapping("/list")  //   /list 값이 요청맵핑값이다.
	    public String list([변수,...]){

		return "jsp정보";      // 기본적으로 forward 방식으로 jsp에게 위임한다.
	    }
            @RequestMapping("/add")  //   /add 값이 요청맵핑값이다.
	    public String add([변수,...]){

		return "jsp정보";
	    }

       - Controller의 메서드 리턴타입은 다양한 타입 지정 가능.
         예> String, void, DeptDTO, List<DeptDTO>,...
	 만약 String 이면 View 정보가 된다. ( JSP 정보 )
    
       - Controller의 메서드 파라미터도 다양한 타입 지정 가능.

       - Controller의 @RequestMapping 에 설정하는 요청맵핑값은 다양한 포맷지정이 가능하다.
         예> /list,  /list*, /list/*, /list/**

   라. jsp 저장
     - jsp 및 css/js/image 등을 저장하기 위해서는
       기본적인 웹 어플리케이션 디렉터리 구조가 있음.
                 webapp (*****)
		    META-INF
		      MANIFEST.MF
		    WEB-INF
		       lib
		       web.xml
		    
		    hello.html (정적)
		    test.css
		    test.js
		    test.png
		    world.jsp (동적)
       그런데 spring boot에서는 기본적으로 웹 어플리케이션 디렉터리 구조를 제공 안함.
       이유는 spring boot는 jsp 권장 안함 ( 대신 thymeleaf (타임리프) 권장, *.html 지정 )
        https://www.thymeleaf.org/
     - spring boot의 웹 디렉토리 구조는 다음과 같다.

       src/main/resources 
              META-INF
	          resources
		      WEB-INF
		          views (폴더)
			      hello.jsp  <== WEB-INF에 저장한 이유는 웹브라우저에서 직접 접근 불가.
			                 Controller가 알려준 jsp가진 DispatcherServlet만 접근가능.

     - jsp 의존성 설정
        # JSP 의존성 설정
	<dependency>
		<groupId>org.apache.tomcat.embed</groupId>
		<artifactId>tomcat-embed-jasper</artifactId>
		<scope>provided</scope>
	</dependency> 
	<dependency>
		<groupId>javax.servlet</groupId>
		<artifactId>jstl</artifactId>
	</dependency>

    - jsp 위한 이클립스 플러그인 설치하기
      
      이클립스 help > Eclipse market place >  'eclipse web' 검색 > 
                    Eclipse Enterprise java and Web Developer tools 3.33 설치하기 

  
    마. Controller에서 JSP 선택하기 위한 prefix와 suffix 설정

      # 현재코드는 다음과 같은 문제가 있음

        return "/WEB-INF/views/hello.jsp";  <== 경로가 길다. 확장자가 jsp로 고정되어 있음.

      # 수정코드
      
         return "hello";  <== 파일명만 지정.

         추가로 application.properties 에 파일경로와 확장자 정보를 알려줌.
         # jsp의 경로와 확장자 지정
	spring.mvc.view.prefix=/WEB-INF/views/
	spring.mvc.view.suffix=.jsp
	

    바. jsp에서 정적파일 사용하기 ( js, css, image )

      - 정적파일은 src/main/resources/static 폴더에 저장해야 된다.
      
      a. static 폴더 작성

        src/main/resources/
	                  static
			       js
			         test.js
			       css
			         test.css
			       images
			         logo_daum.png
     b. jsp 사용

       <link rel="stylesheet" href="css/test.css">
       <script src="js/test.js"></script>
       <img src="images/logo_daum.png" width="100" height="100">

########################################################################

3) 요청맵핑값의 패턴1

  @RequestMapping("요청맵핑값")

 예>
  @RequestMapping("/list")
  @RequestMapping(value = {"/list2","/listAll"})
  @RequestMapping("/update*")
  @RequestMapping("/delete/*")
  @RequestMapping("/add/**")

  @RequestMapping("/find/**/board") <== 패턴 에러
   해결: spring.mvc.pathmatch.matching-strategy=ant-path-matcher
  https://docs.spring.io/spring-boot/docs/2.7.18/reference/html/web.html#web.servlet.spring-mvc.content-negotiation


3) 요청맵핑값의 패턴2

   @RequestMapping("요청맵핑값") 의 클래스 레벨 사용가능

   # 현재 
    ==> 회원정보보기/ 회원생성하기 / 회원수정하기/ 회원삭제하기
    @RequestMapping("/member")
    @RequestMapping("/member/list")
    @RequestMapping("/member/add")
    @RequestMapping("/member/update")
    @RequestMapping("/member/delete")

   # 적용
   @RequestMapping("/member")
   public class MainController2{

         @RequestMapping("/list")
	 public String list(){}

	 @RequestMapping("/add")
	 public String add(){}

	 @RequestMapping
	 public String default(){}
   }


 3) 요청맵핑값의 패턴3

   - GET|POST 방식 명시 가능.

   예> 로그인(회원가입) 작업은 반드시 2번 요청해야 된다.
     이유는 첫번째 요청은 화면요청(GET방식)이고 두번째 실제 로직 요청(POST방식)이다.

    # 현재

     @RequestMapping("/loginForm") <== 화면요청, GET 방식이용이 일반적
     public String loginForm(){}

     @RequestMapping("/login") <== 로직 요청, POST 방식이용이 일반적
     public String login(){}


   # 적용
     ==> 요청맵핑값은 /login으로 동일하지만 method 방식이 달라서 요청에 대한 식별이 가능하다.

     @RequestMapping(value="/login", method=RequestMethod.GET) <== 화면요청, GET 방식이용이 일반적
     public String loginForm(){}


     @RequestMapping(value="/login", method==RequestMethod.POST) <== 로직 요청, POST 방식이용이 일반적
     public String login(){}


    * Spring Framework 4.3 이후에 어노테이션이 추가됨.

     @RequestMapping(value="/login", method=RequestMethod.GET) 해당되는

  ==>@GetMapping("/login")

     @RequestMapping(value="/login", method==RequestMethod.POST) 해당되는

  ==>@PostMapping("/login")


  * PRG(Post-Redirect-Get) 패턴을 적용해서 최종적인 작업은 post가 아닌 get로 끝나게 처리해야 된다.
 ######################################################################################

4) 요청 파라미터 얻기1- 단일값( name 하나에 value 하나 )

 - 이전 서블릿/jsp의 request.getParameter("name") 역할 및 POST요청시 한글처리 명시적으로 구현.
 - Spring MVC에서는 POST 요청시에도 한글처리가 자동으로 지원됨. 

 방법1:

        @PostMapping("/login")
	public String add(HttpServletRequest request) {
		String userid = request.getParameter("userid");
		String passwd = request.getParameter("passwd");

       ==> 서블릿/jsp에서는 "userid"가 없으면 null 값을 반환했음.

 방법2(******):
      @PostMapping("/login")
	public String login(@RequestParam("userid") String userid,
			    @RequestParam("passwd") String passwd) {
		
		logger.info("logger:userid={},passwd={}", userid, passwd);

   * @RequestParam 는 필수사항으로 반드시 name값에 해당되는 파라미터가 제공되어야 한다.
    따라서 name값에 해당되는 값이 없으면 null 이 아닌 400(bad request)에러가 발생된다.
    필수사항을 옵션으로 변경가능하다. ( 에러가 아닌 null값이 저장됨 )
    추가로 null 값 대신에 기본값 설정도 가능하다.

방법3:
       @PostMapping("/login")
	public String login(@RequestParam(name = "userid2", 
	                                  required = false, 
	                                  defaultValue = "aaa") String userid,
			            @RequestParam("passwd") String passwd) {


 방법 4:  name 값과 저장할 파라미터 변수가 동일하면 name값 생략 가능
       @PostMapping("/login")
	public String login(@RequestParam String userid,
			            @RequestParam("passwd") String pw) {
		
 방법5(*******):  DTO에 직접 저장(단 name 값과 DTO의 변수명이 동일한 경우)

        @PostMapping("/login")
	public String login(LoginDTO dto) {
		
		logger.info("logger:userid={},passwd={}", dto.getUserid(), dto.getPasswd());

 방법6:  Map 계열로 저장.

        @PostMapping("/login")
	public String login(@RequestParam Map<String, String> map) {
		
		logger.info("logger:Map:{}",map);
		return "redirect:xxx"; 
	}

4) 요청 파라미터 얻기2- 멀티값( name 하나에 value 여러개 )

  -  이전 서블릿/jsp의 request.getParameterValues("name") 역할.

  방법1: @RequestParam  + 배열로 처리
      @PostMapping("/member1")
	public String member1(       @RequestParam("userid") String userid,
			             @RequestParam("passwd") String passwd, 
			             @RequestParam("email")  String [] email
			            )

  방법2: @RequestParam + List로 처리
       @PostMapping("/member2")
	public String member2(       @RequestParam("userid") String userid,
			             @RequestParam("passwd") String passwd, 
			             @RequestParam("email") List<String> email
			            ) {

  방법3(******): DTO
       
        public class MemberDTO {

	String userid;
	String passwd;
	
	List<String> email; // String [] email 가능

        @PostMapping("/member")
	public String member(MemberDTO dto) {
		
		logger.info("logger:MemberDTO:{}", dto);

###################################################################
5) 요청헤더값 얻기
   ==> 헤더의 name값은 기본적으로 대소문자 구별 안함.

   # 모든 요청헤더값 얻기
     //요청헤더값 전부 얻기
	@GetMapping("/header")
	public String header(HttpServletRequest request) {
	  Enumeration<String> names = request.getHeaderNames();
		
	    while(names.hasMoreElements()) {
	    	String name = names.nextElement();
	    	String value = request.getHeader(name);
	    	logger.info("logger:header name:{}, header value:{}", name, value);
	    }
		return "hello";
	}

   # 특정 헤더값 얻기
     // 특정 헤더값 얻기 ( 대소문자 구별안함. Accept 와 accept는 동일한 name으로 처리됨 )
	@GetMapping("/header2")
	public String header2(@RequestHeader("user-agent") String x,
			      @RequestHeader("Accept-language") String x2,
			      @RequestHeader("Accept") String x3
			               ) {
		logger.info("logger:user-agent:{}, accept-language:{}, accept:{}", x, x2, x3);
	 
		return "hello";
	}


6) 쿠키값 얻기

  # 전체 쿠키 얻기
    // 쿠키 얻기1- 전체 쿠키 얻기
		@GetMapping("/get-cookie1")
		public String get_cookie1(HttpServletRequest request) {
			
			Cookie [] cookies = request.getCookies();
			for (Cookie c : cookies) {
				String name = c.getName();
				String value = c.getValue();
				logger.info("logger:쿠키 name:{}, 쿠키 value:{}", name, value);
			}
			return "hello";
		}
  # 특정 쿠키값 얻기
        @GetMapping("/get-cookie")
	public String get_cookie(@CookieValue("userid") String userid) {
		logger.info("logger:쿠키 name:userid, 쿠키 value:{}", userid);
		return "hello";
	}

###################################################################


  * 아키텍쳐

            요청 처리 ( @RequestParam, @RequestHeader, @CookieValue )           
  웹브라우저 ------------> Controller

                            |
			    |
	 <------------   hello ( /WEB-INF/views/hello.jsp )


7) Model 생성방법 ( jsp에서 보여줄 데이터 의미 )

 - 이전 서블릿/jsp 는  scope에 setAttribute(key,value) 로 저장하고 jsp에서 보여줌.

    scope 종류에 따라서 저장하고 
     
      request.setAttribute(key,value);
      session.setAttribute(key,value);
      application.setAttribute(key,value)
  
   나중에 jsp에 보여줌.
     EL: ${key}

  * Spring에서 JSTL 사용방법
  1) 의존성 설정
     	<dependency>
		<groupId>org.apache.tomcat.embed</groupId>
		<artifactId>tomcat-embed-jasper</artifactId>
		<scope>provided</scope>
	</dependency> 
	<dependency>
		<groupId>javax.servlet</groupId>
		<artifactId>jstl</artifactId>
	</dependency>

   2) jsp에서 taglib 등록
   <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>

  
  방법1: HttpServletRequest 이용

        @GetMapping("/m1")
	public String m1(HttpServletRequest request) {
		request.setAttribute("m1", "홍길동");

 방법2: Model 이용

       @GetMapping("/m2")
	public String m2(Model m) { // 자동으로 new Model()해서 주입됨.
		// 기본적으로 request scope에 저장됨.
		m.addAttribute("m1", "홍길동");
		m.addAttribute("m1_dto", new LoginDTO("홍길동", "1234"));

 방법3: ModelMap 이용
   
    @GetMapping("/m3")
	public String m3(ModelMap m) { // 자동으로 new ModelMap()해서 주입됨.
	        // 기본적으로 request scope에 저장됨.
		m.addAttribute("m1", "홍길동");
		m.addAttribute("m1_dto", new LoginDTO("홍길동", "1234"));

 방법4: Map<String,Object> 이용

     @GetMapping("/m4")
	public String m4(Map<String, Object> m) { // 자동으로 new ModelMap()해서 주입됨.
	       // 기본적으로 request scope에 저장됨.
		m.put("m1", "홍길동");
		m.put("m1_dto", new LoginDTO("홍길동", "1234"));

 방법5: 자동으로 key 사용해서 저장
       	@GetMapping("/m5")
	public String m5(LoginDTO dto) {  
		// LoginDTO 가 Model이 됨. 즉 내부적으로 request.setAttribute( loginDTO , dto );
		// 자동으로 빈 이름(첫글자소문자)으로 key로 설정됨.
		dto.setUserid("이순신");
		dto.setPasswd("9876");
		return "m5";
	}

 방법6(*****): 명시적으로  key 사용해서 저장

       @GetMapping("/m6")
	public String m6(@ModelAttribute("dto_model") LoginDTO dto) {  
		// LoginDTO 가 Model이 됨. 즉 내부적으로 request.setAttribute( 명시적 지정 , dto );
		// key값 설정은 @ModelAttribute("key값") 사용.
		dto.setUserid("이순신");
		dto.setPasswd("9876");
		return "m6";
	}

 방법7:
      @GetMapping("/m7")
	public String m7(@ModelAttribute("list_model") ArrayList<LoginDTO> list) {  
		// LoginDTO 가 Model이 됨. 즉 내부적으로 request.setAttribute( 명시적 지정 , dto );
		// key값 설정은 @ModelAttribute("key값") 사용.
		
		list.add(new LoginDTO("홍길동", "1234"));
		list.add(new LoginDTO("이순신", "9876"));
		return "m7";
	}

 =====> 여기까지가 메서드의 파라미터로 지정해서 Model를 생성함.
       그러면 리턴타입의 String은 View 정보였음( jsp 정보)

 =====> 지금부터는 메서드의 리턴타입으로 Model를 생성함.
       그러면 View 정보는 어떻게 얻을까?  요청맵핑값을 view 정보로 사용한다.

 방법 8: 자동으로 key 사용해서 저장
     
        @GetMapping("/m8") // /WEB-INF/views/m8.jsp 찾음
	public LoginDTO m8() {   // 리턴타입인 LoginDTO가 Model임.
		
		return new LoginDTO("유관순", "1234");
	}

방법 9: 명시적으로  key 사용해서 저장

       @GetMapping("/m9") // /WEB-INF/views/m9.jsp
       @ModelAttribute("dto_model")
	public  LoginDTO m9() {   // 리턴타입인 LoginDTO가 Model임.
		
		return new LoginDTO("유관순", "1234");
	}
       
방법10: 
       @GetMapping("/m10") // /WEB-INF/views/m10.jsp
	@ModelAttribute("list_model")
	public ArrayList<LoginDTO>  m10() {   // 리턴타입인 LoginDTO가 Model임.
		
		ArrayList<LoginDTO> list = new ArrayList<>();
		list.add(new LoginDTO("홍길동", "1234"));
		list.add(new LoginDTO("이순신", "9876"));
		
		return list;
	}

=== > 이전까지는 Model과 View 정보가 분리되서 설정했음.

=== > 지금부터는 Model과 View 정보를 한번에 설정 가능.