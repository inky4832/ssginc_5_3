
Spring 어플리케이션 개발

1. Spring Framework 프로젝트
  - https://spring.io/projects/spring-framework#learn 가서 Reference Doc과 API Doc 참조.
  - 최신 버전인 6 는 JDK 17 부터 지원됨.
  - STS 3 사용해야 됨.

2. Spring Boot 프로젝트
  - https://spring.io/projects/spring-boot#learn 가서 Reference Doc과 API Doc 참조.
  - 최신 버전인 3 는 JDK 17 부터 지원됨.
  - STS 3 및 STS 4 모두 가능

3. 용어 정리

  1) POJO 
   - Plain Old Java Object
   - 플랫폼에 독립적인 형태의 클래스를 의미한다.
   예> CartListServlet는 의존적인 클래스( extends HttpServlet 때문에 Tomcat이 설치된 웹개발에서만 사용가능)
      CartDTO는 독립적인 클래스.

 2) (Spring) Bean
   - Spring 환경에서 사용되는 POJO 기반의 클래스 의미.
   - 개발자가 직접 Bean(클래스)을 new 하지 않음.
     Bean을 자동으로 관리하는 또 다른 Bean(IoC Container)이 제공됨.

    * Java Bean
     - Spring 이전에 사용되었던 이름.
     - EJB ( Enterpries Java Bean )에서 사용했던 명칭.
  

 3) IoC Container ( Inversion of Control Container: 제어의 역행)
   https://docs.spring.io/spring-framework/docs/5.2.25.RELEASE/spring-framework-reference/core.html#beans

   - 개념:
      IoC(Inversion of Control) 방법으로 Spring Bean을 관리(생성~소멸)하기 때문에 붙여진 이름

   - 비슷한용어:
     Spring Container
     Spring Context

   - 기능:
     Spring Bean을 관리(생성~소멸) 및 의존성 설정(DI:Dependency Injection: 의존성 주입).
     (이전 개발방식은 클래스를 직접 생성하고 의존성도 직접 설정했음.
      이런 순방향의 개발이 아닌 완전히 역방향의 개발이기 때문임.
      )

   - IoC Container의 실체는 Spring Bean이다. 계층구조로 되어 있음.

                    BeanFactory  ( 인터페이스 )
                          |                  |
	    XXXApplicationContext       XXXBeanFactory
                    |
            AnnotationConfigApplicationContext
	    GenericXmlApplicationContext
	    XXXWebApplicationContext ( web이 있는 것은 웹어플리케이션 개발용 IoC Container 임)

     BeanFactory: 기본 Spring Container 임.
     ApplicationContext : 기본기능 + enterprise 환경에서 필요한 전용기능이 추가된 컨테이너임
                                   ( 웹개발가능. I18N(국제화:InternationalizatioN), AOP 기능,.. )


  4) DI(Dependency Injection: 의존성 주입)

    - 의존성? A 클래스가 B를 사용하면 A와 B간에 의존성이 생김.
    - 의존성 주입? A(CartService)클래스가 B(CartDAO) 를 참조하기 위해서 외부(CartListServlet)에서 
                A 클래스의 생성자에 B 객체를 생성해서 설정하는 작업을 의미.

		Spring에서는 외부 역할을 IoC Container가 담당한다.

     - 의존성 주입 방법

       가. 생성자 이용한 주입
       https://docs.spring.io/spring-framework/docs/5.2.25.RELEASE/spring-framework-reference/core.html#beans-constructor-injection
       
       나. set메서드 이용한 주입
       https://docs.spring.io/spring-framework/docs/5.2.25.RELEASE/spring-framework-reference/core.html#beans-setter-injection



4. 빌드툴 (build tool)

 1) 개념
   - 개발시 사용되는 자동화 툴.

 2) 종류

   - Maven (메이븐)
      pom.xml ( 설정파일: jdk/boot 버전, 필요한 jar 파일들 설정)

   - Gradle (그레들) 
      build.gradle ( 설정파일: jdk/boot 버전, 필요한 jar 파일들 설정)


  3) 빌드툴 기능

    가. 이전 개발 프로세스

     소스코드작성 ----> 컴파일 ---> 테스트 파일작성(단위테스트) ->컴파일 ------> 패키징(jar/war) --->배포
             
	     필요한 외부 jar 다운
	       + 
             빌드패스
             <---------------------------------------------------------------------------->
	         개발자가 직접 수동으로 해줌.

    나. 빌드툴 적용한 개발 프로세스

      소스코드작성 ----> 컴파일 ---> 테스트 파일작성(단위테스트) ->컴파일 ------> 패키징(jar/war) --->배포
             
	     필요한 외부 jar 다운
	       + 
             빌드패스
              <----------------------------------------------------------------------------->
	                빌드툴이 거의 자동화해줌.


   4) Maven의 기본 디렉터리 구조

      src/main/java :  이전 이클립스의 src 경로와 동일.  *.java 저장
      src/main/resource:  *.java 제외한 나머지 파일들 저장.
                         예> jdbc.properties, EmpMapper.xml ( 이전에는 src 에 저장 )

      src/test/java :  단위 테스트 용도의  *.java 저장
      src/test/resource:  단위 테스트 용도의  *.java 제외한 파일 저장.

      JRE System Library : jdk 11 용 jar파일들 저장.
      Maven Dependencies : SpringBoot에서 사용해야 되는 jar파일들 저장.

        - junit( mockito ) 관련 jar: 단위 테스트 용도
        
	- logback(log4j, slf4j) 관련 jar:  로그출력 ( 로깅: logging )
	                          - 이제부터 System.out.println 더 이상 사용안함.

        - spring-beans, spring-core 관련 jar : Spring Framework

        - spring boot 관련 jar: Spring Boot 

    ===> 저장 경로는 C:\Users\ssginc76\.m2\repository 이다. (로컬 저장소)

       pom.xml ( Project Object Model )
       - 버전, 필요한 jar 정보등 설정
       - 계층구조로 구성됨. ( 부모에 해당하는 pom.xml 있음 )
       - 필요로 하는 jar 파일은 <dependency> 태그로 설정하면 자동으로 다운로드 되고 build path까지 해줌.
         http://mvnrepository.com


    5) Maven의 주요 기능

      가. 의존성 설정
        - pom.xml 에 필요로 하는 jar 파일은 <dependency> 태그로 설정하면 자동으로 다운로드 되고 build path까지 해줌.
	- http://mvnrepository.com 에서 <dependency> 정보를 얻을 수 있음.

     나. 빌드시 사용되는 단계별 명령어

          compile
	  test
	  package
	  install
	  deploy
	  clean

      


5. SpringBoot 프로젝트 생성 방법
 
  ==> 명시적으로 빌드툴 (build tool) 선택해야됨.
  ==> 
     STS 4 버전
       ==> pom.xml 파일의 <project>태그내의 값은 변경해야 된다.
       변경전: https://maven.apache.org/xsd/maven-4.0.0.xsd
       변경후: http://maven.apache.org/xsd/maven-4.0.0.xsd

     JDK: 11 버전
     SpringBoot: 2.7.18 버전

  1) STS에서 직접생성
    - STS에서 New > Spring Starter Project 선택

  2) Spring Initializer 이용한 방법
     - 웹에서 생성후 다운받아서 사용함.
      http://start.spring.io


6. IoC Container에게 빈정보 같은 데이터를 알려주는 방법 ( Configuration 작업 )

  1) XML 이용
  2) 어노테이션 + 약간의 XML
  3) 어노테이션 <== Java Configuration 이라고 부름.

  4) boot ( xml 기반가능, 어노테이션 + 약간의 XML 가능, 어노테이션 가능(기본))
    ==> src/main/resources 의
       application.properties 이용해서 전반적인 환경설정을 설정함.

#############################################################
2일차

1. Spring Boot 등장배경

  - 2016년에 등장.
  - 기존의 framework에서는 개발자가 처리해야 되는 많은 설정이 있었기 때문에
    매우 설정( Configuration 작업 )자체가 복잡했음.
    실제 비즈니스 로직에 집중하지 못함.
    이러한 문제를 해결하기 위해서 Spring Boot 라는 서브 프로젝트가 진행됨.
     Spring Boot 는 많은 설정들을 자동화해서 개발자가 실제 비즈니스 로직에 집중하도록 도와줌.

2. Spring Boot 장점(특징)

  - 설정 자동화
      pom.xml에 의존성 설정하면 자동으로 지정된 의존성에 맞는 환경을 설정해줌.

  - 라이브러리 자동 관리
      maven + starter 
  
  - 웹어플리케이션 프로젝트인 경우에도 jar 실행가능.

    * 어플리케이션 개발후 배포 방법
     
     1) 비웹 어플리케이션
         - 일반적인 Java SE 환경: jar
	 - Spring Framework 환경: jar
         - Spring Boot 환경: jar

     2) 웹 어플리케이션
	 - 기본 Servlet/JSP 환경: war
	 - Spring Framework 환경: war
         - Spring Boot 환경: jar/war

          jar 실행: java -jar  파일명.jar

   - boot 프로젝트의 설정 정보는 src/main/resources 의
     application.properties ( applicaion.yml 야물) 이용해서 전반적인 환경설정을 설정함.

    # application.properties
      server.error.whitelabel.enabled=false
      server.port=8090
 
    # application.yml
      server:
	  error:
	    whitelabel:
	      enabled: false
	      
	  port: 8090
 
3. Spring Boot Starter
https://docs.spring.io/spring-boot/docs/2.7.18/reference/htmlsingle/#using.build-systems.starters

  1) stater 개념
   - 필요한 jar 파일들의 묶음.
     
  2) 참조 사이트
   http://mvnrepository.com 에서 starter 사용가능.


4. XXXXApplication.java 
https://docs.spring.io/spring-boot/docs/2.7.18/reference/htmlsingle/#getting-started.first-application.code.spring-boot-application

    @SpringBootApplication
    public class Application{

        public static void main(String[] args) {
		SpringApplication.run(DemoApplication.class, args);
	}
    }

  - 위 코드는 spring boot에서는 필수코드임.
  - 시작점 역할 담당.
  - @SpringBootApplication 어노테이션 필수로 지정.
    다음 3가지 어노테이션을 포함한다.

    @SpringBootConfiguration
      - 개발자가 필요에 의해서 추가적인 Configuration 설정할 수 있도록 지원.
        (추가적인 설정방법: 클래스 작성하고 @Configuration 지정 )
      - 대표적으로 Spring Security 임.
       예>
          @Configuration
	  public class MyConfiguration{
               // 코드
	  }
    @EnableAutoConfiguration
      - pom.xml에 stater같은 의존성을 설정하면 거의 자동으로 필요한 설정을 해줌.
        즉 자동 구성 메커니즘 활성화.
      - 예> spring-boot-starter-web 지정하면 자동으로 tomcat 설치되고
           404 발생시 자동으로 Whitelable ~ 페이지를 제공하는 등..

    @ComponentScan
      - 자동으로 빈생성하는 방법으로 기본적으로 패키지 단위로 설정해서 
        자동으로 생성하도록 가이드함.
     
      - scan 방법 2가지

        가. 패키지를 지정하지 않는 경우의 scan
 
          - @SpringBootApplication 가진 Application.java의 패키지와 
	    같거나 서브 패키지로 작성하면 자동으로 scan 됨. ( 권장 방법 )

	나. 패키지를 지정한 경우의 scan
	  - 명시적으로 생성할 빈의 패키지명을 알려줘야 된다. 
	    예> @SpringBootApplication(scanBasePackages = {"com.exam2"})

 

###############################################################################3
5. 로깅처리
https://docs.spring.io/spring-boot/docs/2.7.18/reference/htmlsingle/#features.logging

# 로깅레벨에 따른 색상설정시 never 동작안되는 상태 참조
https://stackoverflow.com/questions/48011632/where-is-spring-output-ansi-enabled-configured

  1) 개요
   - System.out.println 대신 특정 값(로그값)을 상황(레벨)에 맞게 콘솔(파일)에 출력.

  2) 로그처리를 전문적으로 해주는 라이브러리

     - log4J 라이브러리 
     - logback 라이브러리 ( boot 기본 로깅 담당 ) 
     - ..

     * 로깅처리 구조

         SLF4J ( 인터페이스, 스펙 ) - log()
          |
          | 구현
      log4J   logback

  3) 로깅레벨

       trace
       debug
       info ( 기본 )
       warn
       error
  
    ==> application.properties 에 로깅레벨을 설정.
    ==> 동작방식은 지정된 레벨 포함한 하위 레벨까지 로깅처리됨. 

  4) boot에서 로깅처리를 담당하는 의존성이 있음
  
     spring-boot-starter 의 서브로
         spring-boot-starter-logging 이 담당
	          log4J
		  logback
		  slf4j

 
  5) 적용
    
    가. application.properties 에 로깅레벨을 설정.
   
      문법:
        logging.level.관심있는패키지명=로그레벨

      # 로깅레벨
      logging.level.org.springframework=debug
      logging.level.com.exam=info
 
      # 파일에 저장1- 경로지정만 함.
      logging.file.path=c://log   ( spring.log 파일이 생성됨 )

      # 파일에 저장2 ( 경로지정 + 파일명 같이 지정 )
      logging.file.name=c:\\temp\\test2.log	

   6) 사용자 지정 로그 출력

      # application.propertis
        logging.level.com.exam=trace


      # java
      import org.slf4j.Logger;
      
      Logger logger = LoggerFactory.getLogger(getClass());


      //로그 출력
	logger.trace("trace:{},{}", "trace1","trace2");
	logger.debug("debug:{}", "debug");
	logger.info("info:{}", "info");
	logger.warn("warn:{}", "warn");
	logger.error("error:{}", "error");

####################################################
6. 빈 생성 방법

  - 항상 Application.java의 패키지와 같거나 서브 패키지로
    빈을 작성하자. (***********************************)

  1) 명시적으로 생성
     - @Configuration + @Bean 이용
     ==> @Configuration 을 통해서 @Bean으로 지정한 빈을 생성했음.
     ==> @Bean 은 메서드 레벨만 가능.
         @Configuration 는 클래스 레벨만 가능.

  2) 다른 패키지로 되어 있는 경우
      - 명시적으로 패키지를 알려줘야 됨.
      - @SpringBootApplication(scanBasePackages = {"com.exam2"})
        public class Application {

  3) 자동으로 생성 (권장 패키지 구조)
  https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.structuring-your-code.locating-the-main-class

    첫번째 작업: @SpringBootAppliction와 같은 패키지이거나 서브 패키지로 작성한다.
    두번째 작업: 클래스에 어노테이션을 지정한다. 
              @Configuration,@Component,@Repository,@Service,@Controller,@RestController

     com.exam
        
	@SpringBootAppliction ( , , @ComponentScan)
	Application.java

              xxx
	        @Configuration ( 빈으로 생성됨) - @Bean으로 빈 생성시 빈정보를 설정하는 빈에서 사용.
	          Test.java
                @Component ( 빈으로 생성됨) <-- 범용적으로 사용
		  Hello.java
                @Repository ( 빈으로 생성됨) <---- DAO 역할의 빈에서 사용
		  World.java
		@Service ( 빈으로 생성됨)    <---- Service 역할의 빈에서 사용
		  World2.java
		@Controller ( 빈으로 생성됨)   , @RestController ( 빈으로 생성됨) 
		  World3.java

                  World4.java
    com.exam2
              yyy
	        @Component
	        Main.java
              


7. 의존성 설정

  - 구조

      DeptService
      @Service                        @Repository
      DeptServiceImpl ---------------> DeptDAO

      DeptDAO dao;
      public DeptServiceImpl(DeptDAO dao){
         this.dao = dao;
      }

  1) 묵시적으로 설정 방법

    가. 생성자 이용 (권장방법)
      DeptDAO dao;
      EmpDAO dao2;

      public DeptServiceImpl(DeptDAO dao, EmpDAO dao2){
         this.dao = dao;
	 this.dao2 = dao2;
      }
  
      - 권장방법
        권장이유는 하나의 블럭에서 모든 주입이 완료됨.
	         또한 주입받는 시점이 생성시점이기 때문에 @Autowired 보다 훨씬 빠름.
      - 기본생성자는 반드시 없어야 됨.


    나. 어노테이션 이용
      - @Autowired 
 
      예> 
        @Autowired
	DeptDAO deptDAO;

	@Autowired
        EmpDAO dao2; 

  2) 명시적 설정 방법
    - skip


  3) 주입 가능한 타입이 여러개 인 경우
   - 기본적으로 에러가 발생됨.
   - 해결:
         @Primary
	 또는
	 @Qualifier("빈이름")

      예>
         @Repository("empDAO")
	 @Primary
         public class EmpDAO


        // 생성자 주입 이용
	public DeptServiceImpl(@Qualifier("deptDAO")   CommonDAO commonDAO) {}


        // @Autowired 이용
        @Autowired
	@Qualifier("empDAO")
	CommonDAO commonDAO;

  
    4) 생성자 주입과 @Autowired 혼합 가능




8. 생성된 빈 접근하는 방법

  ApplicationContext ctx;

  public 생성자(ApplicationContext ctx){
     this.ctx = ctx;
  }

  또는
 @Autowired
 ApplicationContext ctx;

  ctx.getBean("xxx", 클래스명.class);  // @Service("xxx") public class DeptServiceImpl



9. 빈의 scope 

  1) 개념
    빈 생성후에 ctx.getBean() 를 여러번 했을 때 반환되는 빈의 스코프를 의미한다.
    기본적으로 bean은 한번만 생성되고 getBean()을 여러번 했을 때 동일한 인스턴스를 반환함. ( 싱글톤 )

    예>
        DeptServiceImple s = ctx.getBean("xxx",DeptServiceImple.class);
	DeptServiceImple s2 = ctx.getBean("xxx",DeptServiceImple.class);


   2) scope 값 종류

     @Scope(value=상수값)
     예> @Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
        @Scope("singleton") 
        @Scope(value = ConfigurableBeanFactory.SCOPE_SINGLETON) // 기본
        @Scope("prototype") 

    - singleton ( 기본, 단 하나의 빈으로 서비스, thread-unsafe )
    - prototype ( getBean 할 때 마다 매번 생성해서 서비스, thread-safe )

    - request ( web 사용가능.  요청~응답 사이에서만 사용 가능 )
    - session ( web 사용가능.  기본적으로 web브라우저가 open 되어있는 동안 사용 가능 )
    - application ( web 사용가능.  기본적으로 Tomcat컨터네이가 start 되어있는 동안 사용 가능 )

10. 초기화 및 cleanup 작업 처리
https://docs.spring.io/spring-framework/docs/5.2.25.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle

  1) 개요
   - 빈(bean)이 생성되고 의존성 주입(DI) 이후의 
     필요한 초기화 작업 및 자원반납 작업 처리가 가능하도록 지원.

  2) @PostConstruct 와  @PreDestroy  이용

   예>
      @PostConstruct
      public void init(){
          //초기화작업
      }

      @PreDestroy
      public void clean(){
          //cleanup작업
      }

11.  프로파일( Profile )
https://docs.spring.io/spring-boot/docs/2.7.18/reference/htmlsingle/#features.external-config.files.profile-specific

   1) 개요
    - 실제로 개발할 때는 개발환경, Q/A 환경, .. ,  production환경
      다양한 환경을 개발자가 선택적으로 정해서 환경을 맞출 수 있는 개념.
 
    예>
       # 개발환경

       Application.java -------> DeptServiceImple ------>DeptDAO ------> H2(데이터베이스,인메모리)
   

       # production환경

       Application.java -------> EmpServiceImple ------>EmpDAO ------> MySQL(데이터베이스)

    2) profile 에 따라서  properties 파일 선택 방법 
    
      여러 개의 application.properties 필요

      문법: 
          application-프로파일명.properties (yml)

       - application.properties ( 기본 )
           # 동작할 프로파일명 지정
	   spring.profiles.active=prod  <== 지정한 프로파일명에 해당하는 
	                                     application-프로파일.properties가 실제로 실행됨.

         application-dev.properties  ( 개발용 )
         application-prod.properties  ( product용 )	


  3) profile 에 따라서  빈(bean) 파일 선택 방법

     application.properties ( 기본 )
           # 동작할 프로파일명 지정
     spring.profiles.active=prod


     @Profile("dev")
     public class DevBean{}

      @Profile("prod")
     public class ProdBean{}


    OOP ( Object Oriented Programming: 객체 지향 프로그래밍 )
12. AOP ( Aspect Oriented Programming: 관점 지향 프로그래밍 )
https://docs.spring.io/spring-framework/docs/5.2.25.RELEASE/spring-framework-reference/core.html#aop
   1) 개념
    
     브라우저 ----------------> A서블릿 -----> 서비스 -----> DAO ------> DB
                             (핵심기능:필수)     (핵심기능)    (핵심기능)
			       +             +          +
			      부수기능:로깅)  부수기능:로깅)    부수기능:로깅)
			      
    브라우저 ----------------> B서블릿 -----> 서비스 -----> DAO ------> DB
                             (핵심기능)     (핵심기능)    (핵심기능)
			                    +          +
			                   부수기능:로깅)    부수기능:로깅)


    - 각 layer가 달라도 공통적으로 사용되는 코드들이 있음(부수기능).
      예> 로그처리

    
    - 최종적인 AOP 개념은 다음과 같다.
      핵심기능과 부수기능(공통기능)을 분리하고 필요시 부수기능을 주입 받아서 구현하는 개발 방법론 의미.

    
    2) AOP 기술

      가. AOP 원천기술
         - AspectJ ( 1995년 )
	 - 굉장히 무겁다.
	   startup 시간이 많이 걸림.
         - target class의 많은 이벤트가 발생시 AOP 적용될 수 있다.
	   예> 변수값이 변경,
	      생성자 호출,
	      메서드 호출,
	      ...

      나. Spring AOP
        - 원천기술인 AspectJ에서 일부분의 기술만 빌려와서 만듬.
	- Spring 기반의 AOP 프레임워크.
        - target class에서 메서드 호출(*****)되는 이벤트에서만 AOP가 적용됨.



     3) 용어정리
     
      가. Aspect
         - 여러 빈에 공통적으로 사용되는 부수기능을 구현한 빈을 의미.
	 - @Aspect 어노테이션 사용

      나. JoinPoint
         - 핵심기능에 Aspect가 적용되는 시점을 의미.
	   Spring AOP에서는 메서드 호출되는 시점만을 의미한다.

	 - 이벤트로 적용됨.
	 예> 핵심기능에서 발생 가능한 이벤트 종류?
	   
	    # 핵심기능 ( 타겟클래스: target class )
	    @Service
	    public class DeptServiceImpl{

                 int num;  // 값 변경 이벤트

		 public void setNum(int n){} // 메서드 호출 이벤트
		 public int getNum(){}     // 메서드 호출 이벤트
		 public DeptServiceImpl(){} // 생성자 호출 이벤트
		 ..
	    }


            # 부가기능(로깅처리)
	    @Aspect
	    public class MyAspect{

	        public void log_print(){
                  s.o.p("로그출력");
		}

	    }

       다. PointCut
       https://docs.spring.io/spring-framework/docs/5.2.25.RELEASE/spring-framework-reference/core.html#aop-pointcuts-examples
          - JoinPoint는 AOP가 주입되는 시점인 메서드 호출시점을 의미하고
	    PointCut 는 메서드들 중에서 어떤 메서드를 호출했을 때 주입할 것인지를
	    알려주는 표현식이다.

          - execution("public int getNum()")
	    execution("public int get*()")
	    execution("public * get*()")
	    execution("public * get*(**)")
	 
	라.  Advice
           - JoinPoint는 AOP가 주입되는 시점인 메서드 호출시점을 의미하고
	      PointCut 는 메서드들 중에서 어떤 메서드를 호출했을 때 주입할 것인지를
	      알려주는 표현식이고
	      Advice 호출된 메서드 전/후/성공/에러/(전,후,성공,에러)/ 시점을 의미.

	      전: @Before
	      후: @After 
             성공: @AfterReturning
	     실패: @AfterThrowing
             (전,후,성공,에러): @Around  

	   예>

	       # 사용

	       DeptServiceImpl service = ctx.getBean();

	       //전
               int n = service.getNum();
               //후

    마. weaving
      - target object 와 aspect 연결의미.


  4) 구현

    가. 의존성 설정
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-aop</artifactId>
	</dependency>
	
	==> aspectjweaver-1.9.7.jar 다운로드됨.

    나. Aspect 작성
      - 부가기능을 구현한 빈
      - @Aspect 어노테이션 지정


    다. Aspect 내에서 advice와 pointcut 을 설정

      - @Before(pointcut설정)
         - target object의 필수기능인 메서드가 호출하기전에 위빙
         예> @Before("execution(public * say*(..))")

      - @After(pointcut설정)
         - target object의 필수기능인 메서드가 호출하기후에 위빙
         예> @After("execution(public * say*(..))")


       - @AfterReturning(pointcut=pointcut설정, returning=리턴값저장변수설정)
        https://docs.spring.io/spring-framework/docs/5.2.25.RELEASE/spring-framework-reference/core.html#aop-advice-after-returning

          - target object의 필수기능인 메서드가 리턴한 값을 얻을 수 있다.
          예> 
	  @AfterReturning(pointcut="execution(public * say*(..))", returning = "xxx")
	public void afterLogging(JoinPoint join, Object xxx) {

   
        - @AfterThrowing(pointcut=pointcut설정, throwing=발생된예외저장변수설정)
	    - target object의 필수기능인 메서드가 예외발생 되었을 때
	    예>
	    @AfterThrowing(pointcut="execution(public * say*(..))", throwing = "ex")
	    public void afterThrowingLogging(JoinPoint join, Exception ex) {

      - @Aroud(pointcut설정)
        
	   - @Before + @After + @AfterReturning + @AfterReturning 모두 포함하는 기능
           예>
	       public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {
      
			Object retVal = pjp.proceed();

			return retVal;
               }